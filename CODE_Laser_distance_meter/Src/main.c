 /**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include "stm32f4xx.h"

#include <stdint.h>
#include <stdbool.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>  // for usleep


#include "GPIOxDriver.h"
#include "BasicTimer.h"
#include "USARTxDriver.h"
#include "RCCHunMHz.h"
#include "PwmDriver.h"

void inSystem (void);
void parseCommands(char *stringVector);
void builtTerminalString (char** terminalString);



//Definición Handlers
//GPIO
//Pin del User blinky
GPIO_Handler_t handlerPinA5         = {0};

//Pines de comunicacion USART
GPIO_Handler_t handlerPinRx         = {0};
GPIO_Handler_t handlerPinTx         = {0};

// Pin de salida PWM
GPIO_Handler_t handlerPinPWM = {0};

//Pin para visualizar la velocidad del micro
GPIO_Handler_t handlerMCO2Show      = {0};

//Timers
BasicTimer_Handler_t handlerTimerBlinky = {0}; // Timer 3
BasicTimer_Handler_t handlerADCTim = {0}; // Timer 4 ADC

//PWM
PWM_Handler_t handlerPwm   = {0};

//handler para ADC
ADC_Config_t handlerADCJoy = {0};

//Usart
USART_Handler_t handlerUSART ={0};

// Variables para los comandos
char bufferReception[64];
uint8_t counterReception = 0;
uint8_t rxData = '\0';
char cmd[32];
unsigned int firstParameter;
unsigned int secondParameter;
unsigned int thirdParameter;
char userMsg[64];
char bufferMsg[64];

// ADC variables
uint32_t adcData[2] ;
uint8_t counterADC = 0;

// Banderas
uint8_t adcFlag = RESET;
uint8_t doneTransaction = RESET;

//Mensajes
const char* msg_NotWorking = "\n--------Astar isn't working properly----------\n";
const char* msg_InsertGrid = "\n------------Insert the char grid--------------\n";

// OTRAS VARIABLES
uint8_t dutty_cycle = 0;

int main(void)
{

	//Activamos el FPU o la unidad de punto flotante
 	SCB -> CPACR |= (0xF << 20);


	inSystem ();


    /* Loop forever */
	while(1){





		if (rxData != '\0'){
			bufferReception[counterReception] = rxData;
			counterReception++;

			if (rxData == '@'){
				doneTransaction = SET;

				bufferReception[counterReception] = '\0';

				counterReception = 0;

			}

			rxData = '\0';

		}

		if (doneTransaction){
			parseCommands(bufferReception);
			doneTransaction = RESET;
		}


	}// FIN DEL LOOP
}


void inSystem (void){


	// Activamos la maxima velocidad del microcontrolador
	RCC_enableMaxFrequencies(RCC_100MHz);
	//Config del pin A8 salida de la velocidad del micro

//	handlerMCO2Show.pGPIOx                             = GPIOC;
//	handlerMCO2Show.GPIO_PinConfig.GPIO_PinNumber      = PIN_9 ;
//	handlerMCO2Show.GPIO_PinConfig.GPIO_PinAltFunMode  = AF0;
//	handlerMCO2Show.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
//	GPIO_Config(&handlerMCO2Show);

	//BLINKY LED
	handlerPinA5.pGPIOx = GPIOA;
	handlerPinA5.GPIO_PinConfig.GPIO_PinAltFunMode = AF0;
	handlerPinA5.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	handlerPinA5.GPIO_PinConfig.GPIO_PinOPType = GPIO_OTYPE_PUSHPULL;
	handlerPinA5.GPIO_PinConfig.GPIO_PinNumber = PIN_5;
	handlerPinA5.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinA5.GPIO_PinConfig.GPIO_PinSpeed = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerPinA5);
	GPIO_WritePin(&handlerPinA5, SET);

	handlerTimerBlinky.ptrTIMx                           = TIM3;
	handlerTimerBlinky.TIMx_Config.TIMx_interruptEnable  = BTIMER_ENABLE_INTERRUPT;
	handlerTimerBlinky.TIMx_Config.TIMx_mode             = BTIMER_MODE_UP;
	handlerTimerBlinky.TIMx_Config.TIMx_speed            = BTIMER_SPEED_100MHz_100us;
	handlerTimerBlinky.TIMx_Config.TIMx_period           = 1000;
	BasicTimer_Config(&handlerTimerBlinky);
	startTimer(&handlerTimerBlinky);



	//////////////////////////////////////////////////// /////////////////// //////////////////////////////////////////////

	///////////////////////////////////////////Comunicación serial para comandos //////////////////////////////////////////////


	//Comunicacion serial

	handlerPinRx.pGPIOx                             = GPIOA;
	handlerPinRx.GPIO_PinConfig.GPIO_PinAltFunMode  = AF7;
	handlerPinRx.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handlerPinRx.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerPinRx.GPIO_PinConfig.GPIO_PinNumber      = PIN_3;
	handlerPinRx.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinRx.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_HIGH;
	GPIO_Config(&handlerPinRx);

	handlerPinTx.pGPIOx                             = GPIOA;
	handlerPinTx.GPIO_PinConfig.GPIO_PinAltFunMode  = AF7;
	handlerPinTx.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handlerPinTx.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerPinTx.GPIO_PinConfig.GPIO_PinNumber      = PIN_2;
	handlerPinTx.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinTx.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_HIGH;
	GPIO_Config(&handlerPinTx);

	handlerUSART.ptrUSARTx                      = USART2;
	handlerUSART.USART_Config.USART_MCUvelocity = USART_50MHz_VELOCITY;
	handlerUSART.USART_Config.USART_baudrate    = USART_BAUDRATE_19200;
	handlerUSART.USART_Config.USART_enableInRx  = USART_INTERRUPT_RX_ENABLE;
	handlerUSART.USART_Config.USART_enableInTx  = USART_INTERRUPT_TX_DISABLE;
	handlerUSART.USART_Config.USART_mode        = USART_MODE_RXTX;
	handlerUSART.USART_Config.USART_parity      = USART_PARITY_NONE;
	handlerUSART.USART_Config.USART_stopbits    = USART_STOPBIT_1;
	handlerUSART.USART_Config.USART_datasize    = USART_DATASIZE_8BIT;
	USART_Config(&handlerUSART);



	//Conversion del JOYSTICK
	handlerADCTim.ptrTIMx = TIM4;
	handlerADCTim.TIMx_Config.TIMx_interruptEnable = BTIMER_ENABLE_INTERRUPT;
	handlerADCTim.TIMx_Config.TIMx_mode = BTIMER_MODE_UP;
	handlerADCTim.TIMx_Config.TIMx_period = 100;
	handlerADCTim.TIMx_Config.TIMx_speed = BTIMER_SPEED_100MHz_100us;
	BasicTimer_Config(&handlerADCTim);


	handlerADCJoy.channelVector[0] = 0;
	handlerADCJoy.channelVector[1] = 1;
	handlerADCJoy.dataAlignment = ADC_ALIGNMENT_RIGHT;
	handlerADCJoy.resolution = ADC_RESOLUTION_12_BIT;
	handlerADCJoy.samplingPeriod = ADC_SAMPLING_PERIOD_28_CYCLES;
	ADC_ConfigMultichannel(&handlerADCJoy, 2);



	// PWM definicion y PIN
	handlerPwmB.ptrTIMx           = TIM2;
	handlerPwmB.config.channel    = PWM_CHANNEL_1;
	handlerPwmB.config.duttyCicle = ;
	handlerPwmB.config.periodo    = 100;
	handlerPwmB.config.prescaler  = BTIMER_SPEED_100MHz_100us;
	pwm_Config(&handlerPwmB);

}


void parseCommands(char *stringVector){

	sscanf(stringVector, "%s %u %u %u %s", cmd ,&firstParameter, &secondParameter, &thirdParameter, userMsg);


	if (strcmp(cmd, "help") == 0){

		writeMsg(&handlerUSART, "HELP MENU CMD : \n");
		writeMsg(&handlerUSART, "1)  astar #parallel Distance #diagonal Distance  \n");

	}



}



// Interrupcion usart 1
void usart2Rx_Callback(void){

	rxData = getRxData();

}

//Callback para comando de setear conversion ADC
void BasicTimer4_Callback(void){
	startSingleADC();
}


//Callback para interrupciones posterior a la multiconversion
void adcComplete_Callback(void){
	counterADC++;
	if ((counterADC % 2) != 0){
		adcData[0] = getADC();
	}else if ((counterADC % 2) == 0){
		adcData[1] = getADC();
		adcFlag = SET;
	}

}

//Interrupción Timer 3
void BasicTimer3_Callback(void){

	GPIOxTooglePin(&handlerPinA5);

}



