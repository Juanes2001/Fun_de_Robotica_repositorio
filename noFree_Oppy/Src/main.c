 /**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stm32f4xx.h>
//
#include <stdint.h>
#include <stdbool.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>  // for usleep


#include "GPIOxDriver.h"
#include "BasicTimer.h"
#include "PwmDriver.h"
#include "USARTxDriver.h"
#include "RCCHunMHz.h"
#include "EXTIDriver.h"
#include "I2CDriver.h"
#include "MPUAccel.h"
#include "MotorsDriver.h"
#include "PosRobt.h"
#include "DMA.h"
#include "Astar.h"


//Definici칩n Handlers
//GPIO
//Pin del User blinky
GPIO_Handler_t handlerPinA5         = {0};

//Pin de Reset
GPIO_Handler_t handlerUserButton    = {0};


//Pines PWM que controlan la velocidad de los motores
GPIO_Handler_t handlerPinPwm_1      = {0};
GPIO_Handler_t handlerPinPwm_2      = {0};

//Pines de comunicacion USART
GPIO_Handler_t handlerPinRx         = {0};
GPIO_Handler_t handlerPinTx         = {0};

//Pin para visualizar la velocidad del micro
GPIO_Handler_t handlerMCO2Show      = {0};

//Pines para encendido y apagado de los motores
GPIO_Handler_t handlerEn2PinC11     = {0};
GPIO_Handler_t handlerEn1PinC10     = {0};

//Pines de salida para la direccion de las ruedas
GPIO_Handler_t handlerIn2PinD2      = {0};
GPIO_Handler_t handlerIn1PinC12     = {0};

//Pines para lectura de encoders
GPIO_Handler_t handlerEncoder1PinC1 = {0};
GPIO_Handler_t handlerEncoder2PinC3 = {0};

// Pines para I2C1
GPIO_Handler_t handler_PINB8_I2C1   = {0};
GPIO_Handler_t handler_PINB9_I2C1   = {0};

//Extis
EXTI_Config_t handlerExtiConEnc_1 = {0};
EXTI_Config_t handlerExtiConEnc_2 = {0};

//Timers
BasicTimer_Handler_t handlerTimerBlinky = {0}; // Timer 3
BasicTimer_Handler_t handlerTIM2_PARAMETROS_MOVIMIENTO    = {0}; // Timer 2
BasicTimer_Handler_t handlerTIM4_time   = {0}; // Timer 4

//PWMs
PWM_Handler_t handlerPWM_1 = {0}; // Timer 5
PWM_Handler_t handlerPWM_2 = {0}; // Timer 5

//Usart
USART_Handler_t handlerUSART = {0};


//I2C
I2C_Handler_t handler_I2C1 = {0};

//DMA
DMA_Handler_t *handler_DMA1[2];

//MPUAccel
MPUAccel_Config handler_MPUAccel_6050 ={0};

// Motor Drivers
Motor_Handler_t *handler_Motor_Array[2]; // Handler para cada motor, 0--> izquierdo; 1--> derecho
Motor_Handler_t handlerMotor1_t;
Motor_Handler_t handlerMotor2_t;

// Astar
AStar_distancesHandler handlerAstarParameters = {0};
costChangesAndPos_t handlerCostsAstar         = {0};


////////ESTRUCTURAS
// Estructura de estados
typedef enum{
	sLine = 0,
	sRoll,
	sNone
}state_t;

typedef struct{
	state_t Mode;
	uint8_t direction_s_r;
}state_dir_t;

//DEFINICION DE FUNCIONES

void inSystem (void);
void parseCommands(char *stringVector);
float calibracionGyros (MPUAccel_Config *ptrMPUAccel, uint8_t axis);
void getAngle(MPUAccel_Config *ptrMPUAccel,float angle_init, double calibr,Parameters_Position_t *ptrParameter_position);
void On_motor_Straigh_Roll(Motor_Handler_t *ptrMotorhandler[2], state_dir_t operation_mode_dir);
void get_measuremets_parameters(Motor_Handler_t *ptrMotorHandler[2], Parameters_Position_t *ptrParameter_position, state_dir_t operation_mode_dir);
void change_dir_straigh_Roll(Motor_Handler_t *ptrMotorhandler[2], state_dir_t operation_mode_dir);
void set_direction_straigh_roll (Motor_Handler_t *ptrMotorhandler[2], state_dir_t operation_mode_dir);
void stop (Motor_Handler_t *ptrMotorhandler[2]);
void int_Config_Motor(Motor_Handler_t *ptrMotorhandler[2],
					  Parameters_Position_t *ptrPosHandler,
					  Parameters_Path_t *ptrPathHandler ,
					  PID_Parameters_t *ptrPIDHandler,
					  state_dir_t *operation_mode_dir);
void PID_calc(PID_Parameters_t *ptrPIDHandler, float time_of_sampling, float setpoint, float current_measure);
void fillComand(void);
void PID_control(Motor_Handler_t *ptrMotorhandler[2],
				 Parameters_Path_t *ptrPathHandler,
				 Parameters_Position_t *ptrPosHandler,
				 PID_Parameters_t *ptrPIDHandler);

void go(Motor_Handler_t *ptrMotorhandler[2],
		MPUAccel_Config *ptrMPUhandler,
		Parameters_Position_t *ptrPosHandler ,
		Parameters_Path_t *ptrPathHandler,
		PID_Parameters_t *ptrPIDHandler,
		double calib ,
		uint8_t *fAnglulo,
		uint8_t *fMeasurements,
		uint8_t *fcontrol,
		char buff[64],
		state_dir_t operation_mode_dir);

int goTo(Motor_Handler_t *ptrMotorhandler[2],
		 MPUAccel_Config *ptrMPUhandler,
		 Parameters_Position_t *ptrPosHandler ,
		 Parameters_Path_t *ptrPathHandler,
		 PID_Parameters_t *ptrPIDHandler,
		 double calib ,
		 uint8_t *fAnglulo,
		 uint8_t *fMeasurements,
		 uint8_t *fcontrol,
		 char buff[64],
		 uint32_t distance_mm ,
		 state_dir_t operation_mode_dir);

void NOP(Motor_Handler_t *ptrMotorhandler[2],
		MPUAccel_Config *ptrMPUhandler,
		Parameters_Position_t *ptrPosHandler ,
		Parameters_Path_t *ptrPathHandler,
		double calib ,
		uint8_t *fAnglulo,
		uint8_t *fMeasurements,
		uint8_t *fcontrol,
		char buff[64],
		state_dir_t operation_mode_dir);

void create_square_operations(double side,
							  uint8_t CW_CCW,
							  Parameters_Operation_t prtList[30],
							  Parameter_build_t *ptrbuild,
							  Parameters_Path_t *ptrPath,
							  Parameters_Position_t *ptrPos);

//-----Macros------
#define distanceBetweenWheels 10600             //Distacia entre ruedas     106,00 [mm]
#define D1 5170                                 //Diametro rueda izquierda  51,70  [mm]
#define D2 5145                                 //Diametro rueda Derecha    51,45 [mm]
#define Ce 72                                   //Numero de interrupciones en el incoder

// Variables para los comandos
char bufferReception[64] = {0};
char bufferReceptionMultiOperations[64] = {0};
uint8_t counterReception = 0;
uint8_t doneTransaction = RESET;
uint8_t rxData = '\0';
char cmd[32];
unsigned int firstParameter  = 0;
unsigned int secondParameter = 0;
unsigned int thirdParameter  = 0;
char data[64];
char userMsg[64];

// ASTART PARAMETERS
// Definici칩n de la matriz de string que almacenar치
char stringMatrix[52][52];

uint8_t stringColumn = 0;
uint8_t stringRow = 0;

// Banderas Astar
uint8_t starWorking = RESET;

//Mensajes
const char* msg_NotWorking = "\n--------Astar isn't working properly----------\n";
const char* msg_InsertGrid = "\n------------Insert the char grid--------------\n";

//////Banderas y estados-----------
state_dir_t Mode_dir      = {0};
state_t Mode              = sNone;
uint8_t flag_angulo       = 0;
uint8_t flag_measurements = 0;
uint8_t flag_Go_Straigh   = 0;
uint8_t flag_GoTo_Straigh = 0;
uint8_t flag_control      = 0;
uint8_t flag_Roll         = 0;
uint8_t flag_RollTo       = 0;
uint8_t Done              = 0;
uint8_t flag_Astar        = 0;
uint8_t Do_the_track      = 0;
uint8_t flag_square       = 0;
uint8_t flag_NOP          = 0;

// TIEMPOS DE SAMPLEO Y CONTEO PARA DEFINICION DE PARAMETROS
uint8_t timeAction_TIMER_Sampling = 13;            // Cantidad de cuentas para
uint16_t time_accumulated = 0;
uint16_t counting_action = 0;                     //Contador para la accion
uint32_t time_accion = 0;

//-----Variables PID-----------
PID_Parameters_t parameter_PID_distace = {0};        //estructura para los parametros del PID

/// Variables para Odometria
Parameters_Path_t parameters_Path_Robot    = {0};           //Estructura que almacena los parametros del camino a recorrer
Parameters_Position_t parameters_Pos_Robot = {0}; 	//Estructura que almacena la posicion del robot
Parameter_build_t parameters_buit_Robot = {0};
Parameters_Operation_t parameters_op_Robot = {0};

double cal_Gyro = 0;   // variable que almacena la calibraci칩n del giroscopio
float ang_d = 0;
float sum_ang = 0;
float promAng = 0;
float paso_mm_1 = ((M_PI*D1)/(100*Ce)); // Numero de milimetros por paso de la rueda izquierda [mm]
float paso_mm_2 = ((M_PI*D2)/(100*Ce)); // Numero de milimetros por paso de la rueda derecha   [mm]
double ang_for_Displament = 0;
double ang_complementary = 0;
float velSetPoint = 0;
int counter;
uint8_t counter_operation;
float vel_Setpoint_1;
float vel_Setpoint_2;
uint8_t square_dir = 0;
double square_side = 0;

// VARIABLES VARIAS DEL ROBOT
#define fixed_dutty 28 // Fixed dutty cycle, velocidad constante
#define fixed_sample_period 16 // Periodo en milisegundos de muestreo de datos de encoder


int main(void){

	//Activamos el FPU o la unidad de punto flotante
 	SCB -> CPACR |= (0xF << 20);
	RCC_enableMaxFrequencies(RCC_100MHz); // Velocidad maxima del MCU
	inSystem (); // Configuracion global de los perifericos

	//Calculamos el setpoint en la que queremos que el robot controle la velocidad de cada motor
	velSetPoint = (0.00169*fixed_dutty + 0.0619);

	// calibramos el Giroscopio para que tengamos una medida de error controlable
	cal_Gyro = calibracionGyros(&handler_MPUAccel_6050, CALIB_Z); // Calibramos el giroscopio que usaremos

	double angleToGo_Relative = 0;
	double angle_start = 0;

    /* Loop forever */
	while(1){

		if (!flag_Astar){
			fillComand(); // Se puede leer cualquier comando excepto cuando se esta lleyendo el grid de Astar
		}

		if (flag_NOP){

			 NOP(handler_Motor_Array,
				 &handler_MPUAccel_6050,
				 &parameters_Pos_Robot,
				 &parameters_Path_Robot,
				 cal_Gyro,
				 &flag_angulo,
				 &flag_measurements,
				 &flag_control,
				 data,
				 Mode_dir);

			 flag_NOP = RESET;
		}

		// En esta parte ya usamos las medidas halladas para mover el robot en linea recta dependiendo de la operacion y el comando deseado
		if (flag_Go_Straigh){

			// Si llegamos a este comando, lo que se quiere es ir en linea recta usando un control PID

			go(handler_Motor_Array,
			   &handler_MPUAccel_6050,
			   &parameters_Pos_Robot,
			   &parameters_Path_Robot,
			   &parameter_PID_distace,
			   cal_Gyro,
			   &flag_angulo,
			   &flag_measurements,
			   &flag_control,
			   data,
			   Mode_dir);
		}

		if (flag_GoTo_Straigh){

			// SI llegamos a este comando, lo que se quiere es ir en linea recta a cierta distancia usando un control PID


			// esta funcion se encarga de enviar al robot en una linea recta hacia una distancia especifica
			// Para ello lo que se hara es simplemente encender el robot y al mismo tiempo calcular su distancia recorrida
			double distance_to_go = 0;
			uint8_t done = RESET;

			// seteamos la posicion inicial como la posicion actual global del robot
			parameters_Path_Robot.start_position_x = parameters_Pos_Robot.xg_position;
			parameters_Path_Robot.start_position_y = parameters_Pos_Robot.yg_position;

			// seteamos la posicion final usando parametros polares

			//Usando el angulo actual global con respecto al eje x se tiene que
			parameters_Path_Robot.goal_Position_x = parameters_Path_Robot.line_Distance
						* cos(parameters_Pos_Robot.rad_global) + parameters_Path_Robot.start_position_x ; // usando la funcion coseno para hallar la coordenada x de llegada
			parameters_Path_Robot.goal_Position_y = parameters_Path_Robot.line_Distance
						* sin(parameters_Pos_Robot.rad_global) + parameters_Path_Robot.start_position_y ; //usando la funcion coseno para hallar la coordenada y de llegada

			// definimos los parametros del camino en funcion de la situacion actual
			calculation_parameter_distance(&parameters_Path_Robot);

			On_motor_Straigh_Roll(handler_Motor_Array, Mode_dir); // Encendemos el robot en la direccion deseada

			while(!done){
				// calculamos la distancia con la libreria PosRobt.h

				distance_to_go = distance_traveled( &parameters_Path_Robot, parameters_Pos_Robot.xg_position, parameters_Pos_Robot.yg_position);

				// Funci칩n de control del robot
				go(handler_Motor_Array,
				   &handler_MPUAccel_6050,
				   &parameters_Pos_Robot,
				   &parameters_Path_Robot,
				   &parameter_PID_distace,
				   cal_Gyro,
				   &flag_angulo,
				   &flag_measurements,
				   &flag_control,
				   data,
				   Mode_dir); // Con esta funcion hacemos que el robot simplemente se mueva

				if (!(distance_to_go < parameters_Path_Robot.line_Distance)){
					// Paramos el proceso
					done = !done;
				}

				// Observamos si hay algun comando en espera
				fillComand();

			}




			if (Done){parseCommands("stop");}

		}

		if (flag_Roll){

			// Si llegamos a este comando lo que se quiere es girar indefinidamente en cierta direccion (CW o CCW)

			// Cambiamos los parametros
			NOP(handler_Motor_Array,
				&handler_MPUAccel_6050,
				&parameters_Pos_Robot,
				&parameters_Path_Robot,
				cal_Gyro,
				&flag_angulo,
				&flag_measurements,
				&flag_control,
				data,
				Mode_dir);

		}

		if (flag_RollTo){

			// Si llegamos a este comando lo que se quiere es girar un cierto 치ngulo el robot
			Done = RESET; // Reseteamos la bandera
			angle_start = parameters_Pos_Robot.grad_global;

			while (!Done){

				// comparamos el 치ngulo a rotar con el angulo actual, partiendo desde el angulo en el que se estaba
				angleToGo_Relative = abs(parameters_Pos_Robot.grad_global - angle_start);
				// tomamos el angulo global y se lo restamos con el angulo con el que se empezo a rotar

				// Cambiamos los parametros
				NOP(handler_Motor_Array,
				    &handler_MPUAccel_6050,
				    &parameters_Pos_Robot,
				    &parameters_Path_Robot,
				    cal_Gyro,
				 	&flag_angulo,
				    &flag_measurements,
				    &flag_control,
					data,
				    Mode_dir);


				// Analizamos si ya se llego al angulo deseado
				if (!(angleToGo_Relative < parameters_Path_Robot.angle) ){Done = !Done;}
			}

			// Paramos el robot
			if (Done){parseCommands("stop");}
			angleToGo_Relative = 0; // Reseteamos
			Done = RESET; // Reseteamos la bandera
		}

		if (flag_Astar){

			if (rxData != '\0'){

				if (rxData != '@'){
					if (rxData != '\n'){ // Como estamos en Windows, el enter da un par the caracteres \r\n
						if (rxData != '\r'){
							stringMatrix[stringRow][stringColumn] = rxData;
							stringColumn++;
							rxData = '\0';
						}else{
							stringRow++;
							stringColumn = 0;
							rxData = '\0';
						}
					}else{
						rxData = '\0';
					}
				}else{
					doneTransaction = SET;

					stringColumn = 0;
					rxData = '\0';
				}
				if (rxData == 'z'){

					memset(stringMatrix, 0, sizeof(stringMatrix));
					stringRow    = 0;
					stringColumn = 0;
					writeMsg(&handlerUSART, "\n------String Vaciado-----\n \r");
					writeMsg(&handlerUSART, msg_InsertGrid);
					rxData = '\0';
				}

			}

			// Hallamos la ruta mas corta del Grid y con esto ya formamos nuestra matriz de operaciones
			if (doneTransaction){

				starWorking = findShorterWay(stringMatrix, readableGrid, costs, &handlerAstarParameters, &handlerCostsAstar, shorterWay);

				if (starWorking){
					// si se llego hasta aca es porque Astar si funciona correctamente
				}else{
					writeMsg(&handlerUSART, msg_NotWorking);
				}
				memset(stringMatrix, 0, sizeof(stringMatrix));
				stringRow    = 0;
				stringColumn = 0;
				writeMsg(&handlerUSART, "\n------String Vaciado-----\n \r");

				flag_Astar = RESET;
				doneTransaction = RESET;
				Do_the_track = SET;

				parameters_op_Robot.op_Mode = 1; // SETEAMOS EN 1 PARA OPERACIONES DE ASTAR
			}
		}


		if (flag_square){
			// En este comando vamos a usar lo entrado en la terminal para contruir un cuadrado de LxL y que el robot
			// recorra el cuadrado

			// seteamos en la funcion create_square_operation las operaciones necesarias para recorrer el cuadrado
			create_square_operations(square_side,
									 square_dir,
									 &parameters_op_Robot,
									 &parameters_buit_Robot,
									 &parameters_Path_Robot,
									 &parameters_Pos_Robot);

			flag_square = RESET;
			Do_the_track = SET; // Realizamos las operaciones
			parameters_op_Robot.op_Mode = 0; // SETEAMOS EN 1 PARA OPERACIONES DE SQUARE

		}


		if (Do_the_track){

			// Si estamos aqui es porque queremos que nuestro robot haga unas operaciones contiguas
			switch (parameters_op_Robot.op_Mode) {
				case 0:{

					counter_operation = 0;
					parameters_op_Robot.op_Mode = 2;

					parseCommands("reinit"); //reiniciamos todos los parametros

					break;
				}case 1:{
					// PAra este caso queremos un Astar,por lo que seteamos las operaciones necesarias despues de haber
					// hallado los puntos a recorrer

					create_Astar_operations(&handlerAstarParameters,
											shorterWay,
											parameters_Path_Robot.Operation_List,
											&parameters_buit_Robot,
											&parameters_Path_Robot,
											&parameters_Pos_Robot);

					counter_operation = 0;
					parameters_op_Robot.op_Mode = 2;

					parseCommands("reinit"); //reiniciamos todos los parametros

					break;

				}case 2:{

					// Esperamos 3 segundos
					delay_ms(3000);

					// Este caso representa la ejecuci칩n de las operaciones almacenadas en la lista de operaciones

					if (parameters_Path_Robot.Operation_List[counter_operation].operacion == LINE){

						// Creamos el comando para que haga la tarea respectiva a ir en linea recta

						parameters_Path_Robot.line_Distance =
								sqrt(pow((parameters_Path_Robot.Operation_List[counter_operation].x_destination*10 - parameters_Pos_Robot.xg_position),2)+
								     pow((parameters_Path_Robot.Operation_List[counter_operation].y_destination*10 - parameters_Pos_Robot.yg_position),2));


						sprintf(bufferReception, "goto %u %.2f" , 1 , parameters_Path_Robot.line_Distance); // Mandamos una direccion hacia adelante
						// y ademas la distancia a recorrer

						parseCommands(bufferReception); // Mandamos el comando

						counter_operation++;

						// fin de la operacion de linea recta

					}else if (parameters_Path_Robot.Operation_List[counter_operation].operacion == TURN){
						// Creamos el comando para que haga la tarea para que gire un cierto 치ngulo

						// metemos el angulo a rotar, ya sea positivo o negativo

						if (parameters_Path_Robot.Operation_List[counter_operation].grad_Rotative < 0 ){
							sprintf(bufferReception,
									"rollto %u %.2f" ,
									0 , // CCW
									-parameters_Path_Robot.Operation_List[counter_operation].grad_Rotative);
						}else{
							sprintf(bufferReception,
									"rollto %u %.2f" ,
									1 , // CW
									parameters_Path_Robot.Operation_List[counter_operation].grad_Rotative);
						}
						counter_operation++;

					}else{// Al llegar aca es porque se acabaron las operaciones, la ultima operacion sera una operacion nula, lo que indica
						// cerrar el comando de Astar

						Do_the_track = RESET; // Bajamos la bandera de Do_the_track para dejar de hacer operaciones

						// Ya en este punto la bandera de Astar esta bajada por loq ue no tenemos que bajarla nuevamente, y ya
					}

					break;
				}
				default:{break;}
				}// Fin del switch case
			}

	}// End of the loop
}




void inSystem (void){

	//Config del pin A8 salida de la velocidad del micro

//	handlerMCO2Show.pGPIOx                             = GPIOC;
//	handlerMCO2Show.GPIO_PinConfig.GPIO_PinNumber      = PIN_9 ;
//	handlerMCO2Show.GPIO_PinConfig.GPIO_PinAltFunMode  = AF0;
//	handlerMCO2Show.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
//	GPIO_Config(&handlerMCO2Show);

	//BLINKY LED

	handlerPinA5.pGPIOx = GPIOA;
	handlerPinA5.GPIO_PinConfig.GPIO_PinAltFunMode = AF0;
	handlerPinA5.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	handlerPinA5.GPIO_PinConfig.GPIO_PinOPType = GPIO_OTYPE_PUSHPULL;
	handlerPinA5.GPIO_PinConfig.GPIO_PinNumber = PIN_5;
	handlerPinA5.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinA5.GPIO_PinConfig.GPIO_PinSpeed = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerPinA5);
	GPIO_WritePin(&handlerPinA5, SET);

	handlerTimerBlinky.ptrTIMx                           = TIM3;
	handlerTimerBlinky.TIMx_Config.TIMx_interruptEnable  = BTIMER_ENABLE_INTERRUPT;
	handlerTimerBlinky.TIMx_Config.TIMx_mode             = BTIMER_MODE_UP;
	handlerTimerBlinky.TIMx_Config.TIMx_speed            = BTIMER_SPEED_100MHz_100us;
	handlerTimerBlinky.TIMx_Config.TIMx_period           = 500;
	BasicTimer_Config(&handlerTimerBlinky);
	startTimer(&handlerTimerBlinky);


	// DEFINICION DEL TIM4 PARA DELAY
	inTIM4();


	//////////////////////////// INICIALIZAMOS EL ROBOT//////////////////////
	int_Config_Motor(handler_Motor_Array,
					 &parameters_Pos_Robot,
					 &parameters_Path_Robot,
					 &parameter_PID_distace,
					 &Mode_dir);


	//////////////////////////////////////////////////// Velocidad de motores //////////////////////////////////////////////


	//PWM
	// PWM motor 1
	handlerPinPwm_1.pGPIOx                             = GPIOA;
	handlerPinPwm_1.GPIO_PinConfig.GPIO_PinAltFunMode  = AF2;
	handlerPinPwm_1.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handlerPinPwm_1.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerPinPwm_1.GPIO_PinConfig.GPIO_PinNumber      = PIN_0;
	handlerPinPwm_1.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinPwm_1.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerPinPwm_1);

	handlerPWM_1.ptrTIMx            = TIM5;
	handlerPWM_1.config.channel     = PWM_CHANNEL_1;
	handlerPWM_1.config.duttyCicle  = fixed_dutty;
//	counter = fixed_dutty;
	handlerPWM_1.config.periodo     = 33; // se maneja 25 hz por testeo
	handlerPWM_1.config.prescaler   = PWM_SPEED_100MHz_1us;
	handlerPWM_1.config.polarity    = PWM_ENABLE_POLARITY;
	handlerPWM_1.config.optocoupler = PWM_ENABLE_OPTOCOUPLER;
	pwm_Config(&handlerPWM_1);
	startPwmSignal(&handlerPWM_1);

	//PWM motor 2
	handlerPinPwm_2.pGPIOx                             = GPIOA;
	handlerPinPwm_2.GPIO_PinConfig.GPIO_PinAltFunMode  = AF2;
	handlerPinPwm_2.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handlerPinPwm_2.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerPinPwm_2.GPIO_PinConfig.GPIO_PinNumber      = PIN_1;
	handlerPinPwm_2.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinPwm_2.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerPinPwm_2);

	handlerPWM_2.ptrTIMx            = TIM5;
	handlerPWM_2.config.channel     = PWM_CHANNEL_2;
	handlerPWM_2.config.duttyCicle  = fixed_dutty;
	handlerPWM_2.config.periodo     = 33;// se maneja 25 hz por testeo
	handlerPWM_2.config.prescaler   = PWM_SPEED_100MHz_1us;
	handlerPWM_2.config.polarity    = PWM_ENABLE_POLARITY;
	handlerPWM_2.config.optocoupler = PWM_ENABLE_OPTOCOUPLER;
	pwm_Config(&handlerPWM_2);
	startPwmSignal(&handlerPWM_2);


	//////////////////////////////////////////////////// /////////////////// //////////////////////////////////////////////

	////////////////////////////////////// Enable 1 y 2, encendido y apagado de motores //////////////////////////////////////////////



	handlerEn1PinC10.pGPIOx                             = GPIOC;
	handlerEn1PinC10.GPIO_PinConfig.GPIO_PinAltFunMode  = AF0;
	handlerEn1PinC10.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_OUT;
	handlerEn1PinC10.GPIO_PinConfig.GPIO_PinNumber      = PIN_10;
	handlerEn1PinC10.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerEn1PinC10.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerEn1PinC10.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerEn1PinC10);
	GPIO_WritePin_Afopt(&handlerEn1PinC10, RESET);

	handlerEn2PinC11.pGPIOx                             = GPIOC;
	handlerEn2PinC11.GPIO_PinConfig.GPIO_PinAltFunMode  = AF0;
	handlerEn2PinC11.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_OUT;
	handlerEn2PinC11.GPIO_PinConfig.GPIO_PinNumber      = PIN_11;
	handlerEn2PinC11.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerEn2PinC11.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerEn2PinC11.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerEn2PinC11);
	GPIO_WritePin_Afopt(&handlerEn2PinC11, RESET);


	//////////////////////////////////////////////////// /////////////////// //////////////////////////////////////////////

	////////////////////////////////////// In 1 y 2, direccion de colores CW y CCW //////////////////////////////////////////////

	handlerIn1PinC12.pGPIOx                             = GPIOC;
	handlerIn1PinC12.GPIO_PinConfig.GPIO_PinAltFunMode  = AF0;
	handlerIn1PinC12.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_OUT;
	handlerIn1PinC12.GPIO_PinConfig.GPIO_PinNumber      = PIN_12;
	handlerIn1PinC12.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerIn1PinC12.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerIn1PinC12.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerIn1PinC12);
	GPIO_WritePin_Afopt(&handlerIn1PinC12, RESET); // default SET
	handler_Motor_Array[0]->configMotor.dir = SET;

	handlerIn2PinD2.pGPIOx                             = GPIOD;
	handlerIn2PinD2.GPIO_PinConfig.GPIO_PinAltFunMode  = AF0;
	handlerIn2PinD2.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_OUT;
	handlerIn2PinD2.GPIO_PinConfig.GPIO_PinNumber      = PIN_2;
	handlerIn2PinD2.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerIn2PinD2.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerIn2PinD2.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerIn2PinD2);
	GPIO_WritePin_Afopt(&handlerIn2PinD2, RESET); // default SET
	handler_Motor_Array[1]->configMotor.dir = SET;

	//////////////////////////////////////////////////// /////////////////// //////////////////////////////////////////////

	////////////////////////////////////// Conteo de encoders motor 1 y motor 2//////////////////////////////////////////////


	handlerEncoder1PinC1.pGPIOx                             = GPIOC;
	handlerEncoder1PinC1.GPIO_PinConfig.GPIO_PinAltFunMode  = AF0;
	handlerEncoder1PinC1.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_IN;
	handlerEncoder1PinC1.GPIO_PinConfig.GPIO_PinNumber      = PIN_1;
	handlerEncoder1PinC1.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerEncoder1PinC1.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerEncoder1PinC1.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_FAST;
	handlerExtiConEnc_1.pGPIOHandler                        = &handlerEncoder1PinC1;
	handlerExtiConEnc_1.edgeType                            = EXTERNAL_INTERRUPT_RASINGANDFALLING_EDGE;
	extInt_Config(&handlerExtiConEnc_1);

	handlerEncoder2PinC3.pGPIOx                             = GPIOC;
	handlerEncoder2PinC3.GPIO_PinConfig.GPIO_PinAltFunMode  = AF0;
	handlerEncoder2PinC3.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_IN;
	handlerEncoder2PinC3.GPIO_PinConfig.GPIO_PinNumber      = PIN_3;
	handlerEncoder2PinC3.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerEncoder2PinC3.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerEncoder2PinC3.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_FAST;
	handlerExtiConEnc_2.pGPIOHandler                        = &handlerEncoder2PinC3;
	handlerExtiConEnc_2.edgeType                            = EXTERNAL_INTERRUPT_RASINGANDFALLING_EDGE;
	extInt_Config(&handlerExtiConEnc_2);



	//////////////////////////////////////////////////// /////////////////// //////////////////////////////////////////////

	///////////////////////////////////////////Comunicaci칩n serial para comandos //////////////////////////////////////////////
		/////////A2 TX // A3 RX PARA USART 2 /////////
		////////A9 TX // A10 RX PARA USART 1 ////////

	//Comunicacion serial

	handlerPinTx.pGPIOx                             = GPIOA;
	handlerPinTx.GPIO_PinConfig.GPIO_PinAltFunMode  = AF7;
	handlerPinTx.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handlerPinTx.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerPinTx.GPIO_PinConfig.GPIO_PinNumber      = PIN_2;
	handlerPinTx.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinTx.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_HIGH;
	GPIO_Config(&handlerPinTx);

	handlerPinRx.pGPIOx                             = GPIOA;
	handlerPinRx.GPIO_PinConfig.GPIO_PinAltFunMode  = AF7;
	handlerPinRx.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handlerPinRx.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerPinRx.GPIO_PinConfig.GPIO_PinNumber      = PIN_3;
	handlerPinRx.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinRx.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_HIGH;
	GPIO_Config(&handlerPinRx);

	handlerUSART.ptrUSARTx                      = USART2;
	handlerUSART.USART_Config.USART_MCUvelocity = USART_50MHz_VELOCITY;
	handlerUSART.USART_Config.USART_baudrate    = USART_BAUDRATE_19200;
	handlerUSART.USART_Config.USART_enableInRx  = USART_INTERRUPT_RX_ENABLE;
	handlerUSART.USART_Config.USART_enableInTx  = USART_INTERRUPT_TX_DISABLE;
	handlerUSART.USART_Config.USART_mode        = USART_MODE_RXTX;
	handlerUSART.USART_Config.USART_parity      = USART_PARITY_NONE;
	handlerUSART.USART_Config.USART_stopbits    = USART_STOPBIT_1;
	handlerUSART.USART_Config.USART_datasize    = USART_DATASIZE_8BIT;
	USART_Config(&handlerUSART);

	//////////////////////////////////////////////////// /////////////////// //////////////////////////////////////////////

	///////////////////////////////////////////Timer para el control de la velocidad//////////////////////////////////////////////

	handlerTIM2_PARAMETROS_MOVIMIENTO.ptrTIMx                           = TIM2;
	handlerTIM2_PARAMETROS_MOVIMIENTO.TIMx_Config.TIMx_interruptEnable  = BTIMER_ENABLE_INTERRUPT;
	handlerTIM2_PARAMETROS_MOVIMIENTO.TIMx_Config.TIMx_mode             = BTIMER_MODE_UP;
	handlerTIM2_PARAMETROS_MOVIMIENTO.TIMx_Config.TIMx_speed            = BTIMER_SPEED_100MHz_10us;
	handlerTIM2_PARAMETROS_MOVIMIENTO.TIMx_Config.TIMx_period           = fixed_sample_period;
	BasicTimer_Config(&handlerTIM2_PARAMETROS_MOVIMIENTO);
	startTimer(&handlerTIM2_PARAMETROS_MOVIMIENTO); // Comenzamos el muestreo de datos con los que aplicaremos un control adecuado


	//////////////////////////////////////////////////// /////////////////// //////////////////////////////////////////////

		////////////////////////////////Configuracion PINES B8 (SCL) B9 (SDA) e I2C1 //////////////////////////////////////////////


//	handler_DMA1[0]->ptrDMAType = DMA1;
//	handler_DMA1[0]->ptrDMAStream = DMA1_Stream0;
//
//	handler_DMA1[1]->ptrDMAType = DMA1;
//	handler_DMA1[1]->ptrDMAStream = DMA1_Stream6;
//	config_DMA(handler_DMA1);

	handler_PINB8_I2C1.pGPIOx                             = GPIOB;
	handler_PINB8_I2C1.GPIO_PinConfig.GPIO_PinAltFunMode  = AF4;
	handler_PINB8_I2C1.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handler_PINB8_I2C1.GPIO_PinConfig.GPIO_PinNumber      = PIN_8;
	handler_PINB8_I2C1.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_OPENDRAIN;
	handler_PINB8_I2C1.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handler_PINB8_I2C1.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_FAST;

	handler_PINB9_I2C1.pGPIOx                             = GPIOB;
	handler_PINB9_I2C1.GPIO_PinConfig.GPIO_PinAltFunMode  = AF4;
	handler_PINB9_I2C1.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handler_PINB9_I2C1.GPIO_PinConfig.GPIO_PinNumber      = PIN_9;
	handler_PINB9_I2C1.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_OPENDRAIN;
	handler_PINB9_I2C1.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handler_PINB9_I2C1.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_FAST;

	handler_I2C1.ptrI2Cx = I2C1;
	handler_I2C1.I2C_Config.clkSpeed = MAIN_CLOCK_50_MHz_FOR_I2C;
	handler_I2C1.I2C_Config.slaveAddress = ADDRESS_DOWN;
	handler_I2C1.I2C_Config.modeI2C = I2C_MODE_FM;

	handler_MPUAccel_6050.ptrGPIOhandlerSCL  = &handler_PINB8_I2C1;
	handler_MPUAccel_6050.ptrGPIOhandlerSDA  = &handler_PINB9_I2C1;
	handler_MPUAccel_6050.ptrI2Chandler   = &handler_I2C1;
	handler_MPUAccel_6050.fullScaleACCEL  = ACCEL_2G;
	handler_MPUAccel_6050.fullScaleGYRO   = GYRO_250;
	configMPUAccel(&handler_MPUAccel_6050);

}


void parseCommands(char *stringVector){

	sscanf(stringVector, "%s %u %u %u %s", cmd ,&firstParameter, &secondParameter, &thirdParameter, userMsg);


	if (strcmp(cmd, "help") == 0){

		writeMsg(&handlerUSART, "HELP MENU CMD : \n");
		writeMsg(&handlerUSART, "1)  go #dir 1--> Ahead , 0-->back Ward\n");
		writeMsg(&handlerUSART, "2)  goto #dir #Distance \n");
		writeMsg(&handlerUSART, "3)  roll #dir_roll 1--> CW , 0-->CCW \n");
		writeMsg(&handlerUSART, "4)  rollto #dir_roll #angle  \n");
		writeMsg(&handlerUSART, "5)  change #dir #operation 1--->Line , 0--->Roll \n");
		writeMsg(&handlerUSART, "6)  square #dir_roll #side_distance (cm)  \n");
		writeMsg(&handlerUSART, "7)  Astar  #Parallel-distance #Diagonal-distance \n");
		writeMsg(&handlerUSART, "8)  reinit  \n");
		writeMsg(&handlerUSART, " \n");

	}else if (strcmp(cmd, "go") == 0){
		// Si estamos aqui se quiere solo que el robot vaya hacia adelante y el linea recta
		Mode_dir.Mode = Mode = sLine;
		Mode_dir.direction_s_r = firstParameter;

		On_motor_Straigh_Roll(handler_Motor_Array,  Mode_dir); // Encendemos los motores para irnos hacia adelante y con una velocidad fija

		// Levantamos la bandera correspondiente a este comando

		flag_Go_Straigh = SET;

		writeMsg(&handlerUSART, "\n____COMANDO go EJECUTADO____\n\r");

	}else if (strcmp(cmd, "goto") == 0){
		Mode_dir.Mode = Mode = sLine ;
		Mode_dir.direction_s_r = firstParameter;

		// Si estamos aqui es porque se quiere ir recorriendo una distancia especifica
		On_motor_Straigh_Roll(handler_Motor_Array, Mode_dir); // Encendemos los motores para irnos hacia adelante y con una velocidad fija

		parameters_Path_Robot.line_Distance = secondParameter; // almacenamos la distancia en milimrtros a recorrer

		flag_GoTo_Straigh = SET;

		writeMsg(&handlerUSART, "\n____COMANDO goto EJECUTADO____\n\r");

	}else if (strcmp(cmd, "roll") == 0){
		// si estamos aqui, este comando lo que hara es girar el robot indefinidamente
		Mode_dir.Mode = Mode = sRoll;
		Mode_dir.direction_s_r = firstParameter;

		// Si estamos aqui es porque se quiere ir recorriendo una distancia especifica
		On_motor_Straigh_Roll(handler_Motor_Array, Mode_dir); // Encendemos los motores para irnos hacia adelante y con una velocidad fija

		flag_Roll = SET;

		writeMsg(&handlerUSART, "\n____COMANDO roll EJECUTADO____\n\r");

	}else if (strcmp(cmd, "rollto") == 0){
		// si estamos aqui, este comando lo que hara es girar el robot indefinidamente
		Mode_dir.Mode = Mode = sRoll;
		Mode_dir.direction_s_r = firstParameter;

		// Si estamos aqui es porque se quiere ir recorriendo una distancia especifica
		On_motor_Straigh_Roll(handler_Motor_Array, Mode_dir); // Encendemos los motores para irnos hacia adelante y con una velocidad fija

		// Almacenamos el angulo al que se quiere ir
		parameters_Path_Robot.angle = secondParameter;

		flag_RollTo = SET;

		writeMsg(&handlerUSART, "\n____COMANDO rollto EJECUTADO____\n\r");


	}else if (strcmp(cmd, "reinit") == 0){

		// en este comando reiniciamos las variables del sistema para volver a empezar desde un nuevo punto de referencia
		int_Config_Motor(handler_Motor_Array,
						&parameters_Pos_Robot,
						&parameters_Path_Robot,
						&parameter_PID_distace,
						&Mode_dir);

		writeMsg(&handlerUSART, "\n____COMANDO reinit EJECUTADO____\n\r");

	}else if (strcmp(cmd, "change") == 0){
		// Si estamos en este comando lo que se desea es que haya un cambio de direccion y de operacion
		if (Mode == sLine ){
			Mode_dir.direction_s_r = firstParameter;
			change_dir_straigh_Roll(handler_Motor_Array, Mode_dir);
		}else if (Mode == sRoll ){
			Mode_dir.direction_s_r = firstParameter;
			change_dir_straigh_Roll(handler_Motor_Array, Mode_dir);
		}

		writeMsg(&handlerUSART, "\n____COMANDO reinit EJECUTADO____\n\r");

	}else if (strcmp(cmd, "Astar") == 0){


		//////////////////////////////////////////////  ASTAR - Algoritm setup//////////////////////////////////////////////////////////

		// Solo necesitamos definir las distancias paralela y diagonal de la malla
		handlerAstarParameters.parallelDistance  = firstParameter;
		handlerAstarParameters.diagonalDiastance = secondParameter;
		writeMsg(&handlerUSART, msg_InsertGrid);

		writeMsg(&handlerUSART, "\n_____________Insert * for  empty space______________\n");
		writeMsg(&handlerUSART, "\n_____________Insert e for  the end space____________\n");
		writeMsg(&handlerUSART, "\n_____________Insert s for  the start space__________\n");
		writeMsg(&handlerUSART, "\n_____________Insert # for  obstacules_______________\n");
		initSerialComunication(&handlerUSART, &handlerPinRx, &handlerPinTx);
		flag_Astar = SET;

	}else if (strcmp(cmd, "square") == 0){

			square_dir  = firstParameter; // Direccion del cuadrado
			square_side = secondParameter; // lado del cuadrado en cm

			flag_square = SET; // Levantamos la bandera para Square

	}else if (strcmp(cmd, "stop") == 0){
		 // Este comando lo que busca es apagar el robot y detenerlo de su estado de movimiento
		stop(handler_Motor_Array); // Apagamos los motores

		// Bajamos las banderas de movimiento alguno
		flag_Go_Straigh   = RESET;
		flag_GoTo_Straigh = RESET;
		flag_Roll         = RESET;
		flag_RollTo       = RESET;
		Mode_dir.Mode     = sNone;


	}else if (strcmp(cmd, "stoptimer") == 0){
		stopTimer(&handlerTIM2_PARAMETROS_MOVIMIENTO); // Paramos de medir
	}


	else {
		writeMsg(&handlerUSART, "\r\n _____________Comando Incorrecto :c_____________ \n");
	}


}

// Interrupcion usart 1
void usart2Rx_Callback(void){
	rxData = getRxData();
}

//Interrupci칩n Timer 3
void BasicTimer3_Callback(void){
	GPIOxTooglePin(&handlerPinA5);
}

//Interrupcion Timer 2

void BasicTimer2_Callback(void){

	// Levantamos bandera que calcula el angulo actual
	flag_angulo = SET;

	// Levantamos la bandera que corresponde con los calculos  odometricos del robot, como la distancia
	// Recorrida, la posicion actual y la velocidad

	//----------------Accion a realizar con un tiempo especifico--------------------
	if(counting_action >= timeAction_TIMER_Sampling){
			flag_measurements = SET;
	}else{ counting_action++; }

	if (Mode_dir.Mode == sNone){
		flag_NOP = SET;
	}

	// EN LA FUNCION 'GO' ESTAN LAS DOS BANDERAS SE ANALIZARAN Y SE EJECUTARAN
}


//Interrupciones de Exti
void callback_extInt1(void){
	// Aumentamos las cuentas
	if (Mode_dir.Mode != sNone){
		handler_Motor_Array[0]->parametersMotor.counts++;
	}
}

void callback_extInt3(void){
	// Aumentamos las cuentas
	if (Mode_dir.Mode != sNone){
		handler_Motor_Array[1]->parametersMotor.counts++;
	}
}


//Definicion de funciones varias


// Calibracion Gyros:

float calibracionGyros (MPUAccel_Config *ptrMPUAccel, uint8_t axis){

	uint16_t  numMedidas = 200;
	float     medidas    = 0;
	float     suma       = 0;
	uint8_t   contador   = 0;
	float     promedio   = 0;

	switch (axis) {
		case 0:{
			while (contador < numMedidas){
				medidas = readGyro_X(ptrMPUAccel);
				suma += medidas;
				contador++;
				delay_ms(1); // esperamos 1 milisegundo
			}
			promedio = suma / numMedidas;
			break;
		}case 1:{
			while (contador < numMedidas){
				medidas = readGyro_Y(ptrMPUAccel);
				suma += medidas;
				contador++;
				delay_ms(1); // esperamos 1 milisegundo
			}
			promedio = suma / numMedidas;
			break;
		}case 2:{
			while (contador < numMedidas){
				medidas = readGyro_Z(ptrMPUAccel);
				suma += medidas;
				contador++;
				delay_ms(1); // esperamos 1 milisegundo
			}
			promedio = suma / numMedidas;
			break;
		}default:{
			break;
		}
	}


	return promedio;
}


void getAngle(MPUAccel_Config *ptrMPUAccel,float angle_init, double calibr, Parameters_Position_t *ptrParameter_position){

	///////////////////////////MEDIDA DEL ANGULO ACUMULADO////////////////////////////////////

	//----------------Accion a Realiza cada interrupci칩n------------------
		//Leemos el 치ngulo
		//Lectura velocidad angular
		float w = readGyro_Z(ptrMPUAccel) - calibr;
		//Calculo angulo
		float ang_d = angle_init + (w * 16)/1000; // conversion de velocidad angular a grados absolutos con respecto al inicio del programa

		ptrParameter_position->grad_relativo = ang_d;

		//Acumulamos los angulos
		sum_ang += ptrParameter_position->grad_relativo;
		//Se acumula el tiempo
		time_accumulated += handlerTIM2_PARAMETROS_MOVIMIENTO.TIMx_Config.TIMx_period;
}

void get_measuremets_parameters(Motor_Handler_t *ptrMotorHandler[2], Parameters_Position_t *ptrParameter_position, state_dir_t operation_mode_dir){

	//Verificamos el modo
	if(operation_mode_dir.Mode == sLine){ // Levantamos la vandera que calcula todos los parametros necesarios para el control

			//Guardamos el tiempo entre acciones especificas
			time_accion = time_accumulated;
			//Calculamos el angulo promedio y la establecemos como el angulo relativo
			promAng = sum_ang / counting_action;
			ptrParameter_position->rad_relativo = (promAng * M_PI) / 180; //[rad]

			ptrParameter_position->grad_global += atan2(sin((sum_ang * M_PI) / 180),
					  	  	  	  	  	  	  	  	    cos((sum_ang * M_PI) / 180)) * (180 / M_PI); //[춿] angulo acumulado global en grados

			ptrParameter_position->rad_global = atan2(sin((ptrParameter_position->grad_global * M_PI) / 180),
													  cos((ptrParameter_position->grad_global * M_PI) / 180)); //[rad]

			// Con la siguiente accion conseguimos que el angulo que deseamos solo este dentro del rango [-pi,pi]
			ptrParameter_position->rad_relativo = atan2(sin(ptrParameter_position->rad_relativo),
														cos(ptrParameter_position->rad_relativo));

			//Calculamos la velocidad
			if (operation_mode_dir.direction_s_r == SET){

				// SI estamos aqui se tiene una direccion deseada hacia adelante
				// almacenamos las variables de velocidad y direcci칩n en funci칩n de hacia donde se este llendo

				ptrMotorHandler[0]->parametersMotor.dis = (paso_mm_1 * ptrMotorHandler[0]->parametersMotor.counts);// Calculamos la distancia recorrida contando cuantos pasos a dado la rueda izquierda //[mm]
				ptrMotorHandler[1]->parametersMotor.dis = (paso_mm_2 * ptrMotorHandler[1]->parametersMotor.counts);// Calculamos la distancia recorrida contando cuantos pasos a dado la rueda derecha   //[mm]
				ptrMotorHandler[0]->parametersMotor.vel = ptrMotorHandler[0]->parametersMotor.dis / time_accion; // Calculamos la velocidad de la rueda izquierda     //[m/s]
				ptrMotorHandler[1]->parametersMotor.vel = ptrMotorHandler[1]->parametersMotor.dis / time_accion; // Calculamos la velocidad de la rueda derecha    //[m/s]

			}else{
				// SI estamos aqui se tiene una direccion deseada hacia atras
				// almacenamos las variables de velocidad y direcci칩n en funci칩n de hacia donde se este llendo

				ptrMotorHandler[0]->parametersMotor.dis = -(paso_mm_1 * ptrMotorHandler[0]->parametersMotor.counts);// Calculamos la distancia recorrida contando cuantos pasos a dado la rueda izquierda //[mm]
				ptrMotorHandler[1]->parametersMotor.dis = -(paso_mm_2 * ptrMotorHandler[1]->parametersMotor.counts);// Calculamos la distancia recorrida contando cuantos pasos a dado la rueda derecha   //[mm]
				ptrMotorHandler[0]->parametersMotor.vel = -ptrMotorHandler[0]->parametersMotor.dis / time_accion; // Calculamos la velocidad de la rueda izquierda     //[m/s]
				ptrMotorHandler[1]->parametersMotor.vel = -ptrMotorHandler[1]->parametersMotor.dis / time_accion; // Calculamos la velocidad de la rueda derecha    //[m/s]

			}

			//Reiniciamos el numero de conteos
			ptrMotorHandler[0]->parametersMotor.counts = 0;
			ptrMotorHandler[1]->parametersMotor.counts = 0;

			//Reiniciamos variable
			sum_ang = 0;

			//Reiniciamos tiempo
			time_accumulated = 0;

			//Reiniciamos el contador de accion
			counting_action = 0;

	}
	else if(operation_mode_dir.Mode == sRoll)
	{
			//Guardamos el tiempo entre acciones especificas
			time_accion = time_accumulated;
			//Calculamos el angulo promedio y la establecemos como el angulo relativo
			promAng = sum_ang / counting_action;
			ptrParameter_position->rad_relativo = (promAng * M_PI) / 180; //[rad]

			ptrParameter_position->grad_global += atan2(sin((sum_ang * M_PI) / 180),
					  	  	  	  	  	  	  	  	    cos((sum_ang * M_PI) / 180)) * (180 / M_PI); //[춿] angulo acumulado global en grados

			ptrParameter_position->rad_global = atan2(sin((ptrParameter_position->grad_global * M_PI) / 180),
													  cos((ptrParameter_position->grad_global * M_PI) / 180)); //[rad]

			// Con la siguiente accion conseguimos que el angulo que deseamos solo este dentro del rango [-pi,pi]
			ptrParameter_position->rad_relativo = atan2(sin(ptrParameter_position->rad_relativo),
														cos(ptrParameter_position->rad_relativo));

			//Calculo de la distancia recorrida por cada rueda

			if (operation_mode_dir.direction_s_r == SET){

				// SI estamos aqui se tiene un una direccion de giro CW
				// almacenamos las variables de velocidad y direcci칩n en funci칩n de hacia donde se este girando

				ptrMotorHandler[0]->parametersMotor.dis = (paso_mm_1 * ptrMotorHandler[0]->parametersMotor.counts);// Calculamos la distancia recorrida contando cuantos pasos a dado la rueda izquierda //[mm]
				ptrMotorHandler[1]->parametersMotor.dis = -(paso_mm_2 * ptrMotorHandler[1]->parametersMotor.counts);// Calculamos la distancia recorrida contando cuantos pasos a dado la rueda derecha   //[mm]
				ptrMotorHandler[0]->parametersMotor.vel = ptrMotorHandler[0]->parametersMotor.dis / time_accion; // Calculamos la velocidad de la rueda izquierda     //[m/s]
				ptrMotorHandler[1]->parametersMotor.vel = -ptrMotorHandler[1]->parametersMotor.dis / time_accion; // Calculamos la velocidad de la rueda derecha    //[m/s]

			}else{
				// SI estamos aqui se tiene un una direccion de giro CCW
				// almacenamos las variables de velocidad y direcci칩n en funci칩n de hacia donde se este girando

				ptrMotorHandler[0]->parametersMotor.dis = -(paso_mm_1 * ptrMotorHandler[0]->parametersMotor.counts);// Calculamos la distancia recorrida contando cuantos pasos a dado la rueda izquierda //[mm]
				ptrMotorHandler[1]->parametersMotor.dis = (paso_mm_2 * ptrMotorHandler[1]->parametersMotor.counts);// Calculamos la distancia recorrida contando cuantos pasos a dado la rueda derecha   //[mm]
				ptrMotorHandler[0]->parametersMotor.vel = -ptrMotorHandler[0]->parametersMotor.dis / time_accion; // Calculamos la velocidad de la rueda izquierda     //[m/s]
				ptrMotorHandler[1]->parametersMotor.vel = ptrMotorHandler[1]->parametersMotor.dis / time_accion; // Calculamos la velocidad de la rueda derecha    //[m/s]

			}

			//Reiniciamos el numero de conteos
			ptrMotorHandler[0]->parametersMotor.counts = 0;
			ptrMotorHandler[1]->parametersMotor.counts = 0; // RESETEAMOS LAS CUENTAS

//			//C치lculo 치ngulo debido al desplazamiento del ICR
//			ang_for_Displament += (((ptrMotorHandler[1]->parametersMotor.dis - ptrMotorHandler[0]->parametersMotor.dis) * 100)
//					               / distanceBetweenWheels)*(180/M_PI); //[춿]
//
			//Reiniciamos variable
			sum_ang = 0;
			//Reiniciamos tiempo
			time_accumulated = 0;

			//Reiniciamos el contador de acci칩n
			counting_action  = 0;

		//Combinar ambos 치ngulos
//		ang_complementary = ptrParameter_position->grad_relativo + ang_for_Displament;
	}

	else{ // SI estamos aqui es porque no estamos en ningun modo

		//Guardamos el tiempo entre acciones especificas
		time_accion = time_accumulated;
		//Calculamos el angulo promedio y la establecemos como el angulo relativo
		promAng = sum_ang / counting_action;
		ptrParameter_position->rad_relativo = (promAng * M_PI) / 180; //[rad]

		ptrParameter_position->grad_global += atan2(sin((sum_ang * M_PI) / 180),
													cos((sum_ang * M_PI) / 180)) * (180 / M_PI); //[춿] angulo acumulado global en grados

		ptrParameter_position->rad_global = atan2(sin((ptrParameter_position->grad_global * M_PI) / 180),
												  cos((ptrParameter_position->grad_global * M_PI) / 180)); //[rad]

		// Con la siguiente accion conseguimos que el angulo que deseamos solo este dentro del rango [-pi,pi]
		ptrParameter_position->rad_relativo = atan2(sin(ptrParameter_position->rad_relativo),
													cos(ptrParameter_position->rad_relativo));


		//Reiniciamos el numero de conteos
		ptrMotorHandler[0]->parametersMotor.counts = 0;
		ptrMotorHandler[1]->parametersMotor.counts = 0; // RESETEAMOS LAS CUENTAS

//			//C치lculo 치ngulo debido al desplazamiento del ICR
//			ang_for_Displament += (((ptrMotorHandler[1]->parametersMotor.dis - ptrMotorHandler[0]->parametersMotor.dis) * 100)
//					               / distanceBetweenWheels)*(180/M_PI); //[춿]
//
		//Reiniciamos variable
		sum_ang = 0;
		//Reiniciamos tiempo
		time_accumulated = 0;

		//Reiniciamos el contador de acci칩n
		counting_action  = 0;

	}

}


void On_motor_Straigh_Roll(Motor_Handler_t *ptrMotorhandler[2], state_dir_t operation_mode_dir){


	if (operation_mode_dir.Mode == sLine){
				//Activamos el motor
				// ENCENCEMOS EL MOTOR 1 (LEFT)
					// Seteamos correctamente la direccion de cada motor
					set_direction_straigh_roll(ptrMotorhandler, operation_mode_dir);

					enableOutput(ptrMotorhandler[0]->phandlerPWM);
					GPIO_WritePin_Afopt(ptrMotorhandler[0]->phandlerGPIOEN,SET); // Encendemos el motor 1

					// ENCENCEMOS EL MOTOR 2 (Right)
					//Se enciende el motor 2
					enableOutput(ptrMotorhandler[1]->phandlerPWM);
					GPIO_WritePin_Afopt (ptrMotorhandler[1]->phandlerGPIOEN,SET);


	}else if (operation_mode_dir.Mode == sRoll){
				//Activamos el motor
				// ENCENCEMOS EL MOTOR 1 (LEFT)
					set_direction_straigh_roll(ptrMotorhandler, operation_mode_dir);

					//Se enciende el motor 1
					enableOutput(ptrMotorhandler[0]->phandlerPWM);
					GPIO_WritePin_Afopt(ptrMotorhandler[0]->phandlerGPIOEN,SET); // Encendemos el motor 1

					// ENCENCEMOS EL MOTOR 2 (Right)
					//Se enciende el motor 2
					enableOutput(ptrMotorhandler[1]->phandlerPWM);
					GPIO_WritePin_Afopt (ptrMotorhandler[1]->phandlerGPIOEN,SET);


	}

}

void set_direction_straigh_roll (Motor_Handler_t *ptrMotorhandler[2], state_dir_t operation_mode_dir){

	// Esta funcion setea correctamente la direccion de los motores dependiendo de lo que se quiera.
	if (operation_mode_dir.Mode == sLine){
		// Si estamos aqui es porque queremos Setear la direccion hacia adelante o hacia atras

		// Si queremos ir hacia adelante

		// Primero revisamos en que direccion se encuentra el robot para ver si si se aplica
		// el cambio o no
		if ((ptrMotorhandler[0]->configMotor.dir != operation_mode_dir.direction_s_r)){
			// cambiamos la direccion cambiando los pines in pero tambien aplicando un toogle al PWM en cada caso
			ptrMotorhandler[0]->configMotor.dir = operation_mode_dir.direction_s_r;
			GPIO_WritePin_Afopt(ptrMotorhandler[0]->phandlerGPIOIN, !ptrMotorhandler[0]->configMotor.dir); // La direccion estaba en RESET, la cambiamos a SET
			PWMx_Toggle(ptrMotorhandler[0]->phandlerPWM);

		}

		if ((ptrMotorhandler[1]->configMotor.dir != operation_mode_dir.direction_s_r)){
			// cambiamos la direccion cambiando los pines in pero tambien aplicando un toogle al PWM en cada caso
			ptrMotorhandler[1]->configMotor.dir = operation_mode_dir.direction_s_r;
			GPIO_WritePin_Afopt(ptrMotorhandler[1]->phandlerGPIOIN,!ptrMotorhandler[1]->configMotor.dir); // La direccion estaba en RESET, la cambiamos a SET
			PWMx_Toggle(ptrMotorhandler[1]->phandlerPWM);
		}
		// Puede que no analice ningun if y simplemente no haga nada

	}else if (operation_mode_dir.Mode == sRoll){
		// si estamos aca es porque queremos cambiar la direccion de rotacion, Solo en el caso requerido

			// Si queremos ir en centido CW o horario

			// Primero revisamos en que direccion se encuentra el robot para ver si si se aplica
			// el cambio o no
			if ((ptrMotorhandler[0]->configMotor.dir == operation_mode_dir.direction_s_r)){
				// cambiamos la direccion cambiando los pines in pero tambien aplicando un toogle al PWM en cada caso
				ptrMotorhandler[0]->configMotor.dir  =  !operation_mode_dir.direction_s_r;
				GPIO_WritePin_Afopt(ptrMotorhandler[0]->phandlerGPIOIN, !ptrMotorhandler[0]->configMotor.dir); // La direccion estaba en RESET, la cambiamos a SET
				PWMx_Toggle(ptrMotorhandler[0]->phandlerPWM);

			}

			if ((ptrMotorhandler[1]->configMotor.dir != operation_mode_dir.direction_s_r)){
				// cambiamos la direccion cambiando los pines in pero tambien aplicando un toogle al PWM en cada caso
				ptrMotorhandler[1]->configMotor.dir = operation_mode_dir.direction_s_r;
				GPIO_WritePin_Afopt(ptrMotorhandler[1]->phandlerGPIOIN, !ptrMotorhandler[1]->configMotor.dir); // La direccion estaba en SET, la cambiamos a RESET
				PWMx_Toggle(ptrMotorhandler[1]->phandlerPWM);
			}
			// Puede que no analice ningun if y simplemente no haga nada
	}
}

void change_dir_straigh_Roll(Motor_Handler_t *ptrMotorhandler[2], state_dir_t operation_mode_dir){

	if (operation_mode_dir.Mode == sLine){
		// Si estamos aqui es porque queremos cambiar la direccion en linea recta correctamente

		// antes de cambiar la direccion apagamos los motores
		GPIO_WritePin_Afopt(ptrMotorhandler[0]->phandlerGPIOEN,RESET);
		GPIO_WritePin_Afopt(ptrMotorhandler[1]->phandlerGPIOEN,RESET);

		// Primero revisamos en que direccion se encuentra el robot para ver si si se aplica
		// el cambio o no
		if ((ptrMotorhandler[0]->configMotor.dir != operation_mode_dir.direction_s_r)){
			// si estamos aqui es porque se quiere cambiar la direccion del robot

			// cambiamos la direccion cambiando los pines in pero tambien aplicando un toogle al PWM en cada caso
			ptrMotorhandler[0]->configMotor.dir = operation_mode_dir.direction_s_r;
			GPIO_WritePin_Afopt(ptrMotorhandler[0]->phandlerGPIOIN, !ptrMotorhandler[0]->configMotor.dir); // La direccion estaba en RESET, la cambiamos a SET
			PWMx_Toggle(ptrMotorhandler[0]->phandlerPWM);

		}

		if ((ptrMotorhandler[1]->configMotor.dir != operation_mode_dir.direction_s_r)){
			// si estamos aqui es porque se quiere cambiar la direccion del robot
			ptrMotorhandler[1]->configMotor.dir = operation_mode_dir.direction_s_r;
			// cambiamos la direccion cambiando los pines in pero tambien aplicando un toogle al PWM en cada caso
			GPIO_WritePin_Afopt(ptrMotorhandler[1]->phandlerGPIOIN, !ptrMotorhandler[1]->configMotor.dir); // La direccion estaba en RESET, la cambiamos a SET
			PWMx_Toggle(ptrMotorhandler[1]->phandlerPWM);
		}
		// Puede que no analice ning칰n if y simplemente no haga nada


		// volvemos a encender los motores
		GPIO_WritePin_Afopt(ptrMotorhandler[0]->phandlerGPIOEN,SET);
		GPIO_WritePin_Afopt(ptrMotorhandler[1]->phandlerGPIOEN,SET);





	}else if (operation_mode_dir.Mode == sRoll){
		// si estamos aca es porque queremos cambiar la direccion de rotacion

			// Si queremos ir en centido CW o horario

			// Primero revisamos en que direccion se encuentra el robot para ver si si se aplica
			// el cambio o no
			// si estamos aqui es porque se quiere cambiar la direccion DEL ROBOT A CW

			// antes de cambiar la direccion apagamos los motores
			GPIO_WritePin_Afopt(ptrMotorhandler[0]->phandlerGPIOEN,RESET);
			GPIO_WritePin_Afopt(ptrMotorhandler[1]->phandlerGPIOEN,RESET);

			if ((ptrMotorhandler[0]->configMotor.dir == operation_mode_dir.direction_s_r)){
				// cambiamos la direccion cambiando los pines in pero tambien aplicando un toogle al PWM en cada caso
				ptrMotorhandler[0]->configMotor.dir = !operation_mode_dir.direction_s_r;
				GPIO_WritePin_Afopt(ptrMotorhandler[0]->phandlerGPIOIN, !ptrMotorhandler[0]->configMotor.dir ); // La direccion estaba en RESET, la cambiamos a SET
				PWMx_Toggle(ptrMotorhandler[0]->phandlerPWM);

			}

			if ((ptrMotorhandler[1]->configMotor.dir != operation_mode_dir.direction_s_r)){
				// cambiamos la direccion cambiando los pines in pero tambien aplicando un toogle al PWM en cada caso
				ptrMotorhandler[1]->configMotor.dir = operation_mode_dir.direction_s_r;
				GPIO_WritePin_Afopt(ptrMotorhandler[1]->phandlerGPIOIN, !ptrMotorhandler[1]->configMotor.dir); // La direccion estaba en SET, la cambiamos a RESET
				PWMx_Toggle(ptrMotorhandler[1]->phandlerPWM);
			}
			// Puede que no analice ningun if y simplemente no haga nada


			// volvemos a encender los motores
			GPIO_WritePin_Afopt(ptrMotorhandler[0]->phandlerGPIOEN,SET);
			GPIO_WritePin_Afopt(ptrMotorhandler[1]->phandlerGPIOEN,SET);
	}
}


void stop (Motor_Handler_t *ptrMotorhandler[2]){

	//DESACTIVAMOS EL MOTOR
	// APAGAMOS EL MOTOR 1 (LEFT)
		//Se enciende el motor 1
		disableOutput(ptrMotorhandler[0]->phandlerPWM);
		GPIO_WritePin_Afopt(ptrMotorhandler[0]->phandlerGPIOEN, RESET); // Apagamos el motor 1
		// APAGAMOS EL MOTOR 2 (Right)
		//Se enciende el motor 2
		disableOutput(ptrMotorhandler[1]->phandlerPWM);
		GPIO_WritePin_Afopt (ptrMotorhandler[1]->phandlerGPIOEN,RESET);


}


void int_Config_Motor(Motor_Handler_t *ptrMotorhandler[2],
		              Parameters_Position_t *ptrPosHandler,
					  Parameters_Path_t *ptrPathHandler ,
					  PID_Parameters_t *ptrPIDHandler,
					  state_dir_t *operation_mode_dir){

	//---------------Motor Izquierdo----------------
	ptrMotorhandler[0] = &handlerMotor1_t;

	//Parametro de la se침al del dutty
	ptrMotorhandler[0]->configMotor.dutty =  fixed_dutty;
	//handler de los perifericos
	ptrMotorhandler[0]->phandlerGPIOEN = &handlerEn1PinC10;
	ptrMotorhandler[0]->phandlerGPIOIN = &handlerIn1PinC12;
	ptrMotorhandler[0]->phandlerPWM    = &handlerPWM_1;
	//definicion de parametros
	ptrMotorhandler[0]->parametersMotor.pid->e0 = 0;
	ptrMotorhandler[0]->parametersMotor.pid->e_prev = 0;
	ptrMotorhandler[0]->parametersMotor.pid->u = 0;
	ptrMotorhandler[0]->parametersMotor.pid->e_int = 0;
	//Calculo de Constantes PID
	ptrMotorhandler[0]->parametersMotor.pid->kp = 250;
	ptrMotorhandler[0]->parametersMotor.pid->ki = 0;
	ptrMotorhandler[0]->parametersMotor.pid->kd = 100;

	//---------------Motor Derecho----------------
	//Parametro de la se침al del dutty
	ptrMotorhandler[1] = &handlerMotor2_t;

	ptrMotorhandler[1]->configMotor.dutty =  fixed_dutty;
	//handler de los perifericos
	ptrMotorhandler[1]->phandlerGPIOEN = &handlerEn2PinC11;
	ptrMotorhandler[1]->phandlerGPIOIN = &handlerIn2PinD2;
	ptrMotorhandler[1]->phandlerPWM = &handlerPWM_2;
	//definicion de parametros
	ptrMotorhandler[1]->parametersMotor.pid->e0 =  0;
	ptrMotorhandler[1]->parametersMotor.pid->e_prev = 0;
	ptrMotorhandler[1]->parametersMotor.pid->u =  0;
	ptrMotorhandler[1]->parametersMotor.pid->e_int = 0;
	//Calculo de Constantes PID
	ptrMotorhandler[1]->parametersMotor.pid->kp = 250;
	ptrMotorhandler[1]->parametersMotor.pid->ki = 0;
	ptrMotorhandler[1]->parametersMotor.pid->kd = 100;

	//---------------PID del la distancia-----------------
	//definicion de parametros
	ptrPIDHandler->e0 = ptrPIDHandler->e_prev = 0;
	ptrPIDHandler->u =  ptrPIDHandler->e_int = 0;
	//Calculo de Constantes PID
	ptrPIDHandler->kp = 1.0;
	ptrPIDHandler->ki = 0.1;
	ptrPIDHandler->kd = 0.8;

	//-------------- Parametros de posicion---------------
	ptrPosHandler->grad_global   = 0;
	ptrPosHandler->rad_global    = 0;
	ptrPosHandler->grad_relativo = 0;
	ptrPosHandler->rad_relativo  = 0;
	ptrPosHandler->xr_position   = 0;
	ptrPosHandler->yr_position   = 0;
	ptrPosHandler->xg_position   = ptrPosHandler->xg_position_inicial = 0;
	ptrPosHandler->yg_position   = ptrPosHandler->yg_position_inicial = 0;


	//--------------Parametros de Path-----------------
	ptrPathHandler->angle = 0;
	ptrPathHandler->goal_Position_x = ptrPathHandler->goal_Position_y = 0;
	ptrPathHandler->line_Distance = 0;
	ptrPathHandler->start_position_x = ptrPathHandler->start_position_y = 0;



	// Seteamos la direccion el modo de operacion en None
	operation_mode_dir->Mode = sNone;
}


int goTo(Motor_Handler_t *ptrMotorhandler[2],
		 MPUAccel_Config *ptrMPUhandler,
		 Parameters_Position_t *ptrPosHandler ,
		 Parameters_Path_t *ptrPathHandler,
		 PID_Parameters_t *ptrPIDHandler,
		 double calib ,
		 uint8_t *fAnglulo,
		 uint8_t *fMeasurements,
		 uint8_t *fcontrol,
		 char buff[64],
		 uint32_t distance_mm ,
		 state_dir_t operation_mode_dir){

	// esta funcion se encarga de enviar al robot en una linea recta hacia una distancia especifica
	// Para ello lo que se hara es simplemente encender el robot y al mismo tiempo calcular su distancia recorrida
	double distance_to_go = 0;
	uint8_t done = RESET;

	// seteamos la posicion inicial como la posicion actual global del robot
	ptrPathHandler->start_position_x = ptrPosHandler->xg_position;
	ptrPathHandler->start_position_y = ptrPosHandler->yg_position;

	// seteamos la posicion final usando parametros polares

	//Usando el angulo actual global con respecto al eje x se tiene que
	ptrPathHandler->goal_Position_x = distance_mm * cos(ptrPosHandler->rad_global) + ptrPathHandler->start_position_x ; // usando la funcion coseno para hallar la coordenada x de llegada
	ptrPathHandler->goal_Position_y = distance_mm * sin(ptrPosHandler->rad_global) + ptrPathHandler->start_position_y ; //usando la funcion coseno para hallar la coordenada y de llegada

	// definimos los parametros del camino en funcion de la situacion actual
	calculation_parameter_distance(ptrPathHandler);

	On_motor_Straigh_Roll(ptrMotorhandler, operation_mode_dir); // Encendemos el robot en la direccion deseada

	while(!done){
		// calculamos la distancia con la libreria PosRobt.h

		distance_to_go = distance_traveled( ptrPathHandler, ptrPosHandler->xg_position, ptrPosHandler->yg_position);

		// Funci칩n de control del robot
		go(ptrMotorhandler,
		   ptrMPUhandler,
		   ptrPosHandler,
		   ptrPathHandler,
		   ptrPIDHandler,
		   calib,
		   fAnglulo,
		   fMeasurements,
		   fcontrol,
		   buff,
		   operation_mode_dir); // Con esta funcion hacemos que el robot simplemente se mueva

		if (!(distance_to_go < distance_mm)){
			// Paramos el proceso
			done = !done;
		}

		// Observamos si hay algun comando en espera
		fillComand();

	}


	return done;
}


void PID_control(Motor_Handler_t *ptrMotorhandler[2] ,
		        Parameters_Path_t *ptrPathHandler,
				Parameters_Position_t *ptrPosHandler,
				PID_Parameters_t *ptrPIDHandler){

	//Conversion de tiempo
	float sampling_time = ((float) (handlerTIM2_PARAMETROS_MOVIMIENTO.TIMx_Config.TIMx_period * timeAction_TIMER_Sampling) / 1000); //[s]

	//Control PID para la distancia
	float distance_recta = (distance_to_straight_line(ptrPathHandler, ptrPosHandler->xg_position, ptrPosHandler->yg_position)) / 1000; //[m]

	//Aplicacion del PID par el control de la distancia del robot al centro
	PID_calc(ptrPIDHandler, sampling_time, 0,  distance_recta);

	//Aplicacndo correcion
	vel_Setpoint_1 = velSetPoint - ptrPIDHandler->u; // Cambio en la velocidad de la rueda izquierda
	vel_Setpoint_2 = velSetPoint + ptrPIDHandler->u; // cambio en la velocidad de la rueda derecha

	//Aplicacion del PID par el control de las velocidades
	PID_calc(ptrMotorhandler[0]->parametersMotor.pid, sampling_time, vel_Setpoint_1,  ptrMotorhandler[0]->parametersMotor.vel); // Accion de control 1
	PID_calc(ptrMotorhandler[1]->parametersMotor.pid, sampling_time, vel_Setpoint_2,  ptrMotorhandler[1]->parametersMotor.vel); // Accion de control 2

	//Cambiamos valores
	ptrMotorhandler[0]->configMotor.new_dutty += ptrMotorhandler[0]->parametersMotor.pid->u;
	ptrMotorhandler[1]->configMotor.new_dutty += ptrMotorhandler[1]->parametersMotor.pid->u;

	//Correccion del dutty
	// Primero nos aseguramos de la no saturacion de los motores
	if (ptrMotorhandler[0]->configMotor.new_dutty >= 60){

		ptrMotorhandler[0]->configMotor.new_dutty = 60;// El limite superior sera 60 de dutty

	}else if (ptrMotorhandler[0]->configMotor.new_dutty <= fixed_dutty -5){

		ptrMotorhandler[0]->configMotor.new_dutty = fixed_dutty -5; // el limite inferior seria 5 puntos menos al dutty fijo
	}

	if (ptrMotorhandler[1]->configMotor.new_dutty >= 60){

		ptrMotorhandler[1]->configMotor.new_dutty = 60;// El limite superior sera 60 de dutty

	}else if (ptrMotorhandler[1]->configMotor.new_dutty <= fixed_dutty -5){

		ptrMotorhandler[1]->configMotor.new_dutty = fixed_dutty -5; // el limite inferior seria 5 puntos menos al dutty fijo
	}

}

void PID_calc(PID_Parameters_t *ptrPIDHandler,
		      float time_of_sampling,
			  float setpoint,
			  float current_measure){

	//Calculo del error
	ptrPIDHandler->e0 = setpoint-current_measure;
    // Controle PID
	float P =  ptrPIDHandler->kp*ptrPIDHandler->e0; // control proporcional
	ptrPIDHandler->e_int +=  ptrPIDHandler->e0 * time_of_sampling;
	float I = ptrPIDHandler->ki * ptrPIDHandler->e_int; // Control integral
	float D =  ptrPIDHandler->kd*(ptrPIDHandler->e0 - ptrPIDHandler->e_prev) / time_of_sampling; // control derivativo
	ptrPIDHandler->u = P + I + D;
     //Actualizamos el error
	ptrPIDHandler->e_prev = ptrPIDHandler->e0;
}


void go(Motor_Handler_t *ptrMotorhandler[2],
		MPUAccel_Config *ptrMPUhandler,
		Parameters_Position_t *ptrPosHandler ,
		Parameters_Path_t *ptrPathHandler,
		PID_Parameters_t *ptrPIDHandler,
		double calib ,
		uint8_t *fAnglulo,
		uint8_t *fMeasurements,
		uint8_t *fcontrol,
		char buff[64],
		state_dir_t operation_mode_dir){

	////////////////////////////////////////BLOQUE DE MEDICION Y CONTROL//////////////////////////////////////////////////////


	//En este primera medicion se mide el el angulo actual del robot con respecto a una referencia.
	if (*fAnglulo){ // este se ejecutara cada periodo

		// Medimos el angulo actual
		getAngle(ptrMPUhandler, 0, calib, ptrPosHandler);
		// bajamos la bandera
		*fAnglulo = RESET;
	}
	// En la siguiente medicion medimos todos los parametros necesarios para el control posterior
	if (*fMeasurements){ // Este se ejecutara cada (periodo * 13 cuentas)

		// Medimos el angulo actual
		get_measuremets_parameters(ptrMotorhandler, ptrPosHandler,operation_mode_dir );
		// bajamos la bandera
		*fMeasurements = RESET;
		//Levandamos la bandera de control
		*fcontrol = SET;
	}

	// Control
	if (*fcontrol){

		//Calculo odometria
		double distance_prom = (ptrMotorhandler[1]->parametersMotor.dis + ptrMotorhandler[0]->parametersMotor.dis)/2;//[mm]

		ptrPosHandler->xr_position = distance_prom * (cos(ptrPosHandler->rad_global));        //[mm]
		ptrPosHandler->yr_position = distance_prom * (sin(ptrPosHandler->rad_global));       //[mm]

		//Paso de c.relativa a c.globales
		ptrPosHandler->xg_position +=  ptrPosHandler->xr_position;
		ptrPosHandler->yg_position +=  ptrPosHandler->yr_position;

		//Convertimos el valor y imprimimos en la terminal
		sprintf(buff,"&%#.4f\t%#.4f\n", ptrPosHandler->xg_position , ptrPosHandler->yg_position);

		writeMsg(&handlerUSART, buff);

		PID_control(ptrMotorhandler, ptrPathHandler, ptrPosHandler, ptrPIDHandler);

		*fcontrol = RESET;
	}
}


void NOP(Motor_Handler_t *ptrMotorhandler[2],
		MPUAccel_Config *ptrMPUhandler,
		Parameters_Position_t *ptrPosHandler ,
		Parameters_Path_t *ptrPathHandler,
		double calib ,
		uint8_t *fAnglulo,
		uint8_t *fMeasurements,
		uint8_t *fcontrol,
		char buff[64],
		state_dir_t operation_mode_dir){

	////////////////////////////////////////BLOQUE DE MEDICION Y CONTROL//////////////////////////////////////////////////////


	//En este primera medicion se mide el el angulo actual del robot con respecto a una referencia.
	if (*fAnglulo){ // este se ejecutara cada periodo

		// Medimos el angulo actual
		getAngle(ptrMPUhandler, 0, calib, ptrPosHandler);
		// bajamos la bandera
		*fAnglulo = RESET;
	}
	// En la siguiente medicion medimos todos los parametros necesarios para el control posterior
	if (*fMeasurements){ // Este se ejecutara cada (periodo * 13 cuentas)

		// Medimos el angulo actual
		get_measuremets_parameters(ptrMotorhandler, ptrPosHandler, operation_mode_dir);
		// bajamos la bandera
		*fMeasurements = RESET;
	}

}



void create_square_operations(double side,
							  uint8_t CW_CCW,
							  Parameters_Operation_t prtList[30],
							  Parameter_build_t *ptrbuild,
							  Parameters_Path_t *ptrPath,
							  Parameters_Position_t *ptrPos){

	// Aqui lo que se tendra en cuenta es el listado de operaciones necesarias para recorrer el camino, un listado donde
	// solo sea recorrerlo en el main y leer cada operacion y simplemene usar goto y rollto para aplicar tales operaciones

	// Aqui se va a suponer que donde se resetea el robot es el (0,0) de coordenadas y que su vector directos esta a 0 grados con respecto
	// al eje X, por lo que se puede colocar el robot como sea en la posicion inicial y este calculara sus operaciones dependiendo
	// de su posicion inicial


	double finishline_x = 0;
	double finishline_y = 0;

	ptrPath->start_position_x = ptrbuild->initline_x = 0;
	ptrPath->start_position_y = ptrbuild->initline_y = 0; //posicion de start, considerada como (0,0)


	// Preguntamos si se quiere recorrer el cuadrado en CW o CCW, no importa donde este situado, comenzara en linea recta como primera operaci칩n

	if (CW_CCW == 1) // Se quiere ir en CW
	{

		// calculo del vector unitario del robot

		unitary_vector(ptrPos->rad_global, ptrbuild->delta_before);

		double coordenadas_cuadrado[4][2] = {{side,0},
											 {side,-side},
											 {0,-side},
											 {0,0}}; // Coordenadas (x,y) destino para hacer el cuadrado


		for (uint8_t i = 0 ; i < 4 - 1 ; i++){

			// Seteamos como punto inicial el punto de start y como punto final el siguiente punto a ir


			finishline_x += coordenadas_cuadrado[i][0]; // Coordenada x a ir
			finishline_y += coordenadas_cuadrado[i][1]; // Coordenada y a ir

			ptrPath->goal_Position_x = finishline_x;
			ptrPath->goal_Position_y = finishline_y;

			build_Operation(prtList, ptrbuild, finishline_x, finishline_y); // Agregamos la operaci칩n respectiva ya sea si se tiene que rotar o si

			change_coordinates_position(ptrPath, finishline_x, finishline_y); // Cambiamos de coordenada teorica para seguir construyendo el camino

		}


		// Agregamos la operacion nula
		add_Operation(prtList, ptrbuild->number_operation, NULL_OPERATION, 0, 0, 0);


	}else // Se quiere recorrer el cuadrado en CCW


	{

		// calculo del vector unitario del robot

		unitary_vector(ptrPos->rad_global, ptrbuild->delta_before);

		double coordenadas_cuadrado[4][2] = {{side,0},
											 {side,side},
											 {0,side},
											 {0,0}}; // Coordenadas (x,y) destino para hacer el cuadrado


		for (uint8_t i = 0 ; i < 4 - 1 ; i++){

			// Seteamos como punto inicial el punto de start y como punto final el siguiente punto a ir


			finishline_x += coordenadas_cuadrado[i][0]; // Coordenada x a ir
			finishline_y += coordenadas_cuadrado[i][1]; // Coordenada y a ir

			ptrPath->goal_Position_x = finishline_x;
			ptrPath->goal_Position_y = finishline_y;

			build_Operation(prtList, ptrbuild, finishline_x, finishline_y); // Agregamos la operaci칩n respectiva ya sea si se tiene que rotar o si

			change_coordinates_position(ptrPath, finishline_x, finishline_y); // Cambiamos de coordenada teorica para seguir construyendo el camino

		}


		// Agregamos la operacion nula
		add_Operation(prtList, ptrbuild->number_operation, NULL_OPERATION, 0, 0, 0);


	}




}




void fillComand(void){

	if (rxData != '\0'){
//		writeChar(&handlerUSART, rxData);
		bufferReception[counterReception] = rxData;
		counterReception++;

		if (rxData == '@'){

			bufferReception[counterReception-1] = '\0';

			counterReception = 0;
			parseCommands(bufferReception);

		}else if (rxData == 'z'){

			memset(bufferReception, 0, sizeof(bufferReception));
			counterReception = 0;
			writeMsg(&handlerUSART, "\n___Buffer Vaciado___\n \r");
			rxData = '\0';
		}
		rxData = '\0';
	}

}


