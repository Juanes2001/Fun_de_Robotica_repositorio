/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stm32f4xx.h>

#include <stdint.h>
#include "FreeRTOS.h"
#include "task.h"
#include <stdbool.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>



#include "GPIOxDriver.h"
#include "BasicTimer.h"
#include "PwmDriver.h"
#include "USARTxDriver.h"
#include "RCCHunMHz.h"

/*definicion de variables del sistema*/


#define STACK_SIZE 200

uint32_t SystemCoreClock = 100000000;
/*Cabecera de la funcion de tarea 1 */
void vTaskOne( void * pvParameters );
void vTaskTwo( void * pvParameters );
void inSystem (void);
void parseCommands(char *stringVector);

//Definición Handlers
//GPIO
GPIO_Handler_t handlerPinA5 = {0};
GPIO_Handler_t handlerUserButton = {0};
GPIO_Handler_t handlerPinPwm_1 = {0};
GPIO_Handler_t handlerPinRx = {0};
GPIO_Handler_t handlerPinTx ={0};
GPIO_Handler_t handlerMCO1Show = {};


//Timers
BasicTimer_Handler_t handlerTimerBlinky = {};


//PWMs
PWM_Handler_t handlerPWM_1 = {0};

//Usart
USART_Handler_t handlerUSART2 = {0};


// Variables para los comandos
char bufferReception[64];
uint8_t counterReception = 0;
uint8_t doneTransaction = RESET;
uint8_t rxData = '\0';
char cmd[32];

unsigned int firstParameter;
unsigned int secondParameter;
unsigned int thirdParameter;
char userMsg[64];

//Creacion de tareas

TaskHandle_t xHandleTask1 = NULL;
TaskHandle_t xHandleTask2 = NULL;

extern void SEGGER_UART_init(uint32_t);

int main(void)
{


	//Activamos el FPU o la unidad de punto flotante
 	SCB -> CPACR |= (0xF << 20);


	//Activamos el contador
   	DWT -> CTRL    |= (1 << 0);

	// Configuracion de orden de prioridad
	vInitPrioGroupValue();

   	SEGGER_UART_init(500000);
//	/* Primero configuramos */
	SEGGER_SYSVIEW_Conf();
//	/* Despues activamos el sistema */
	//SEGGER_SYSVIEW_Start();


	inSystem ();

	BaseType_t xReturned;

	xReturned = xTaskCreate(
	                    vTaskOne,       /* Function that implements the task. */
	                    "Task-1",          /* Text name for the task. */
	                    STACK_SIZE,      /* Stack size in words, not bytes. */
						NULL,    /* Parameter passed into the task. */
	                    2,/* Priority at which the task is created. */
	                    &xHandleTask1 );      /* Used to pass out the created task's handle. */


	 configASSERT( xReturned == pdPASS );

	 xReturned = xTaskCreate(
	 	                    vTaskTwo,       /* Function that implements the task. */
	 	                    "Task-2",          /* Text name for the task. */
	 	                    STACK_SIZE,      /* Stack size in words, not bytes. */
	 	                    "HOLA MUNDO",    /* Parameter passed into the task. */
	 	                    2,/* Priority at which the task is created. */
	 	                    &xHandleTask2 );      /* Used to pass out the created task's handle. */


	 /* Start the created tasks running. */
	 vTaskStartScheduler();


    /* Loop forever */
	while(1){
//		GPIOxTooglePin(&handlerPinA5);
//		for (uint16_t steps = 0 ; steps < 10000 ;steps++){
//
//		}


//		if (rxData != '\0'){
//			bufferReception[counterReception] = rxData;
//			counterReception++;
//
//			if (rxData == '@'){
//				doneTransaction = SET;
//
//				bufferReception[counterReception] = '\0';
//
//				counterReception = 0;
//
//			}
//
//			rxData = '\0';
//
//		}
//
//		if (doneTransaction){
//			parseCommands(bufferReception);
//			doneTransaction = RESET;
//		}
//
		//Si se llega hasta aca es porque algo salio mal

	}
}


void inSystem (void){



	RCC_enableMaxFrequencies();
	//Descripción de la configuración
	show_MaxFreq ();


	//Config del pin A8 salida de la velocidad del micro

	handlerMCO1Show.pGPIOx                             = GPIOA;
	handlerMCO1Show.GPIO_PinConfig.GPIO_PinNumber      = PIN_8 ;
	handlerMCO1Show.GPIO_PinConfig.GPIO_PinAltFunMode  = AF0;
	handlerMCO1Show.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	GPIO_Config(&handlerMCO1Show);

	//BLINKY LED

	handlerPinA5.pGPIOx = GPIOA;
	handlerPinA5.GPIO_PinConfig.GPIO_PinAltFunMode = AF0;
	handlerPinA5.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	handlerPinA5.GPIO_PinConfig.GPIO_PinOPType = GPIO_OTYPE_PUSHPULL;
	handlerPinA5.GPIO_PinConfig.GPIO_PinNumber = PIN_5;
	handlerPinA5.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinA5.GPIO_PinConfig.GPIO_PinSpeed = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerPinA5);
	GPIO_WritePin(&handlerPinA5, SET);


	//User Button
	handlerUserButton.pGPIOx = GPIOC;
	handlerUserButton.GPIO_PinConfig.GPIO_PinAltFunMode = AF0;
	handlerUserButton.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN;
	handlerUserButton.GPIO_PinConfig.GPIO_PinNumber = PIN_13;
	handlerUserButton.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	GPIO_Config(&handlerUserButton);

	//PWM

	handlerPinPwm_1.pGPIOx                             = GPIOC;
	handlerPinPwm_1.GPIO_PinConfig.GPIO_PinAltFunMode  = AF2;
	handlerPinPwm_1.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handlerPinPwm_1.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerPinPwm_1.GPIO_PinConfig.GPIO_PinNumber      = PIN_7;
	handlerPinPwm_1.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinPwm_1.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerPinPwm_1);

	handlerPWM_1.ptrTIMx           = TIM3;
	handlerPWM_1.config.channel    = PWM_CHANNEL_2;
	handlerPWM_1.config.duttyCicle = 100;
	handlerPWM_1.config.periodo    = 100;
	handlerPWM_1.config.prescaler  = BTIMER_SPEED_100us;
	handlerPWM_1.config.polarity   = PWM_ENABLE_POLARITY;
	pwm_Config(&handlerPWM_1);

	//Comunicacion serial

	handlerPinTx.pGPIOx                             = GPIOA;
	handlerPinTx.GPIO_PinConfig.GPIO_PinAltFunMode  = AF7;
	handlerPinTx.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handlerPinTx.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerPinTx.GPIO_PinConfig.GPIO_PinNumber      = PIN_2;
	handlerPinTx.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinTx.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerPinTx);


	handlerPinRx.pGPIOx                             = GPIOA;
	handlerPinRx.GPIO_PinConfig.GPIO_PinAltFunMode  = AF7;
	handlerPinRx.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handlerPinRx.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerPinRx.GPIO_PinConfig.GPIO_PinNumber      = PIN_3;
	handlerPinRx.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinRx.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerPinRx);

//	handlerUSART2.ptrUSARTx                      = USART2;
//	handlerUSART2.USART_Config.USART_baudrate    = USART_BAUDRATE_9600;//37,7222 de Mantiza
//	handlerUSART2.USART_Config.USART_enableInRx  = USART_INTERRUPT_RX_ENABLE;
//	handlerUSART2.USART_Config.USART_enableInTx  = USART_INTERRUPT_TX_DISABLE;
//	handlerUSART2.USART_Config.USART_mode        = USART_MODE_RXTX;
//	handlerUSART2.USART_Config.USART_parity      = USART_PARITY_ODD;
//	handlerUSART2.USART_Config.USART_stopbits    = USART_STOPBIT_1;
//	handlerUSART2.USART_Config.USART_datasize    = USART_DATASIZE_9BIT;
//	handlerUSART2.USART_Config.USART_parityError = 0;
//	USART_Config(&handlerUSART2);







}



void vTaskOne( void * pvParameters )
{

	BaseType_t notify_state ={0};
	uint8_t flag = RESET;

   while(1){
	   //printf("%s\n",((char*) pvParameters));
	   if (notify_state == pdTRUE){
		   flag = !flag;
   	   //vTaskDelay((pdMS_TO_TICKS(100)));
	   }

	   if (flag){
		   GPIOxTooglePin(&handlerPinA5);
	   }
	   else{

		   GPIO_WritePin(&handlerPinA5, RESET);
	   }

	   notify_state = xTaskNotifyWait(0,0,NULL,pdMS_TO_TICKS(100));
	   //taskYIELD();
   }
}

void vTaskTwo( void * pvParameters )
{

	uint8_t button_state = 0;
	uint8_t prev_button_state = 0;

   while(1){
//	   printf("%s\n",((char*) pvParameters));
	   button_state = GPIO_ReadPin(&handlerUserButton);

	   if (button_state){
		   if (!prev_button_state){
			   //Notificacion
			   xTaskNotify(xHandleTask1,0,eNoAction);

		   }
	   }

	   prev_button_state = button_state;

	   vTaskDelay((pdMS_TO_TICKS(10)));
	   //GPIO_WritePin(&handlerPinA5, SET);
	   //taskYIELD();
   }
}


void parseCommands(char *stringVector){

	sscanf(stringVector, "%s %u %u %u %s", cmd ,&firstParameter, &secondParameter, &thirdParameter, userMsg);

}
