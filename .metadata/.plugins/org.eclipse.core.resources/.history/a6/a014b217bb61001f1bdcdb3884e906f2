 /**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stm32f4xx.h>

#include <stdint.h>
#include "FreeRTOS.h"
#include "task.h"
#include <stdbool.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>  // for usleep


#include "GPIOxDriver.h"
#include "BasicTimer.h"
#include "PwmDriver.h"
#include "USARTxDriver.h"
#include "RCCHunMHz.h"
#include "EXTIDriver.h"
#include "MotorsDriver.h"
#include "I2CDriver.h"
#include "MPUAccel.h"

void inSystem (void);
void parseCommands(char *stringVector);



//Definición Handlers
//GPIO
//Pin del User blinky
GPIO_Handler_t handlerPinA5         = {0};

//Pines de comunicacion USART
GPIO_Handler_t handlerPinRx         = {0};
GPIO_Handler_t handlerPinTx         = {0};

//Pin para visualizar la velocidad del micro
GPIO_Handler_t handlerMCO2Show      = {0};

//Timers
BasicTimer_Handler_t handlerTimerBlinky = {0}; // Timer 3

//Usart
USART_Handler_t handlerUSART = {0};


// Variables para los comandos
char bufferReception[64];
uint8_t counterReception = 0;
uint8_t doneTransaction = RESET;
uint8_t rxData = '\0';
char cmd[32];
unsigned int firstParameter;
unsigned int secondParameter;
unsigned int thirdParameter;
char userMsg[64];
char bufferMsg[64];


int main(void)
{


	//Activamos el FPU o la unidad de punto flotante
 	SCB -> CPACR |= (0xF << 20);



	inSystem ();


    /* Loop forever */
	while(1){



	}
}


void inSystem (void){


	// Activamos la maxima velocidad del microcontrolador
	RCC_enableMaxFrequencies();
	//Config del pin A8 salida de la velocidad del micro

//	handlerMCO2Show.pGPIOx                             = GPIOC;
//	handlerMCO2Show.GPIO_PinConfig.GPIO_PinNumber      = PIN_9 ;
//	handlerMCO2Show.GPIO_PinConfig.GPIO_PinAltFunMode  = AF0;
//	handlerMCO2Show.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
//	GPIO_Config(&handlerMCO2Show);

	//BLINKY LED

	handlerPinA5.pGPIOx = GPIOA;
	handlerPinA5.GPIO_PinConfig.GPIO_PinAltFunMode = AF0;
	handlerPinA5.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	handlerPinA5.GPIO_PinConfig.GPIO_PinOPType = GPIO_OTYPE_PUSHPULL;
	handlerPinA5.GPIO_PinConfig.GPIO_PinNumber = PIN_5;
	handlerPinA5.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinA5.GPIO_PinConfig.GPIO_PinSpeed = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerPinA5);
	GPIO_WritePin(&handlerPinA5, SET);

	handlerTimerBlinky.ptrTIMx                           = TIM3;
	handlerTimerBlinky.TIMx_Config.TIMx_interruptEnable  = BTIMER_ENABLE_INTERRUPT;
	handlerTimerBlinky.TIMx_Config.TIMx_mode             = BTIMER_MODE_UP;
	handlerTimerBlinky.TIMx_Config.TIMx_speed            = BTIMER_SPEED_100MHz_100us;
	handlerTimerBlinky.TIMx_Config.TIMx_period           = 1000;
	BasicTimer_Config(&handlerTimerBlinky);
	startTimer(&handlerTimerBlinky);



	//////////////////////////////////////////////////// /////////////////// //////////////////////////////////////////////

	///////////////////////////////////////////Comunicación serial para comandos //////////////////////////////////////////////


	//Comunicacion serial

	handlerPinTx.pGPIOx                             = GPIOA;
	handlerPinTx.GPIO_PinConfig.GPIO_PinAltFunMode  = AF7;
	handlerPinTx.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handlerPinTx.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerPinTx.GPIO_PinConfig.GPIO_PinNumber      = PIN_2;
	handlerPinTx.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinTx.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_HIGH;
	GPIO_Config(&handlerPinTx);

	handlerPinRx.pGPIOx                             = GPIOA;
	handlerPinRx.GPIO_PinConfig.GPIO_PinAltFunMode  = AF7;
	handlerPinRx.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handlerPinRx.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerPinRx.GPIO_PinConfig.GPIO_PinNumber      = PIN_3;
	handlerPinRx.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinRx.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_HIGH;
	GPIO_Config(&handlerPinRx);

	handlerUSART.ptrUSARTx                      = USART2;
	handlerUSART.USART_Config.USART_MCUvelocity = USART_50MHz_VELOCITY;
	handlerUSART.USART_Config.USART_baudrate    = USART_BAUDRATE_19200;
	handlerUSART.USART_Config.USART_enableInRx  = USART_INTERRUPT_RX_ENABLE;
	handlerUSART.USART_Config.USART_enableInTx  = USART_INTERRUPT_TX_DISABLE;
	handlerUSART.USART_Config.USART_mode        = USART_MODE_RXTX;
	handlerUSART.USART_Config.USART_parity      = USART_PARITY_NONE;
	handlerUSART.USART_Config.USART_stopbits    = USART_STOPBIT_1;
	handlerUSART.USART_Config.USART_datasize    = USART_DATASIZE_8BIT;
	USART_Config(&handlerUSART);


}


void parseCommands(char *stringVector){

	sscanf(stringVector, "%s %u %u %u %s", cmd ,&firstParameter, &secondParameter, &thirdParameter, userMsg);




	if (strcmp(cmd, "help") == 0){

		writeMsg(&handlerUSART, "HELP MENU CMD : \n");
		writeMsg(&handlerUSART, "1)  start #setPoint #dir --- setPoint de 0 a 9 ---  dir 0 CW 1 CCW \n");
		writeMsg(&handlerUSART, "2)  goTo #dutty #dir #distance  -----dutty de 0 a 100 ||  dir 0 CW 1 CCW || Distancia en mm \n" );
		writeMsg(&handlerUSART, "3)  off \n");
		writeMsg(&handlerUSART, "4)  gyro \n");
		writeMsg(&handlerUSART, " \n");

	}


}



double distanceM1 (void){

	double u_1;

	u_1 = M_PI * (51.45) * handlerMotor1.configM1.counts_M1/ (72) ;

	return u_1;
}

double distanceM2 (void){

	double u_2;

	u_2 = M_PI * (51.70) * handlerMotor2.configM2.counts_M2/ (72) ;

	return u_2;
}


// Interrupcion usart 1
void usart2Rx_Callback(void){

	rxData = getRxData();

}

//Interrupcion Timer 4
void BasicTimer4_Callback(void){

	flagGyro = SET;
	tiempo += 1;

}

//Interrupción Timer 3
void BasicTimer3_Callback(void){

	GPIOxTooglePin(&handlerPinA5);
	counterTIM3++;

}

//Interrupcion Timer 2

void BasicTimer2_Callback(void){

	flagT2 = SET;


}


//Interrupciones de Exti
void callback_extInt1(void){

	handlerMotor1.configM1.counts_M1++;

}

void callback_extInt3(void){

	handlerMotor2.configM2.counts_M2++;
}


//Definicion de funciones varias

// Freno de motores
void breakMotor(void){

	//Se pregunta cual motor se quiere apagar

	if (flagPWM_1){

		//Se apagael motor 1
		flagPWM_1 = disableOutput(&handlerPWM_1);
		GPIO_WritePin_Afopt (&handlerEn1PinC10,RESET);


	}else{

		__NOP();

	}



	if (flagPWM_2){

		//Se apaga el motor 2
		flagPWM_2 = disableOutput(&handlerPWM_2);
		GPIO_WritePin_Afopt (&handlerEn2PinC11,RESET);


	}else{
		__NOP();
	}



	stopTimer(&handlerTIM2_vel);
	enableChangePWM = RESET;


}


// Calibracion Gyros:

float calibracionGyros (MPUAccel_Config *ptrMPUAccel, uint8_t axis){

	uint16_t  numMedidas = 50;
	float    medidas    = 0;
	float    suma       = 0;
	uint8_t  contador   = 0;
	float    promedio   = 0;

	switch (axis) {
		case 'x':{
			while (contador < numMedidas){
				medidas = readGyro_X(ptrMPUAccel);
				suma += medidas;
				contador++;
			}
			promedio = suma / numMedidas;
			break;
		}case 'y':{
			while (contador < numMedidas){
				medidas = readGyro_Y(ptrMPUAccel);
				suma += medidas;
				contador++;
			}
			promedio = suma / numMedidas;
			break;
		}case 'z':{
			while (contador < numMedidas){
				medidas = readGyro_Z(ptrMPUAccel);
				suma += medidas;
				contador++;
			}
			promedio = suma / numMedidas;
			break;
		}default:{
			break;
		}
	}


	return promedio;
}








//void vTaskOne( void * pvParameters )
//{
//
//	BaseType_t notify_state ={0};
//	uint8_t flag = RESET;
//
//   while(1){
//	   //printf("%s\n",((char*) pvParameters));
//	   if (notify_state == pdTRUE){
//		   flag = !flag;
//   	   //vTaskDelay((pdMS_TO_TICKS(100)));
//	   }
//
//	   if (flag){
//		   GPIOxTooglePin(&handlerPinA5);
//	   }
//	   else{
//
//		   GPIO_WritePin(&handlerPinA5, RESET);
//	   }
//
//	   notify_state = xTaskNotifyWait(0,0,NULL,pdMS_TO_TICKS(100));
//	   //taskYIELD();
//   }
//}
//
//void vTaskTwo( void * pvParameters )
//{
//
//	uint8_t button_state = 0;
//	uint8_t prev_button_state = 0;
//
//   while(1){
////	   printf("%s\n",((char*) pvParameters));
//	   button_state = GPIO_ReadPin(&handlerUserButton);
//
//	   if (button_state){
//		   if (!prev_button_state){
//			   //Notificacion
//			   xTaskNotify(xHandleTask1,0,eNoAction);
//
//		   }
//	   }
//
//	   prev_button_state = button_state;
//
//	   vTaskDelay((pdMS_TO_TICKS(10)));
//	   //GPIO_WritePin(&handlerPinA5, SET);
//	   //taskYIELD();
//   }
//}
