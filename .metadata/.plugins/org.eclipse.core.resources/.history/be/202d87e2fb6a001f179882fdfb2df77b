 /**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stm32f4xx.h>

#include <stdint.h>
#include <stdbool.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>  // for usleep


#include "GPIOxDriver.h"
#include "BasicTimer.h"
#include "PwmDriver.h"
#include "USARTxDriver.h"
#include "RCCHunMHz.h"

/*definicion de variables del sistema*/


void inSystem (void);
void parseCommands(char *stringVector);



//DefiniciÃ³n Handlers
//GPIO
//Pin del User blinky
GPIO_Handler_t handlerPinA5 = {0};


//Pin PWM que controla el pulso a 10 ns
GPIO_Handler_t handlerPinPwm_pulse_10ns  = {0};

//Pin para visualizar la velocidad del micro
GPIO_Handler_t handlerMCOShow      = {0};

// Pines RX y TX USART
GPIO_Handler_t handlerRxPin = {0};
GPIO_Handler_t handlerTxPin = {0};

//Timers
BasicTimer_Handler_t handlerTimerBlinky = {0}; // Timer 3
BasicTimer_Handler_t handlerTIM2_vel    = {0}; // Timer 2

//PWMs
PWM_Handler_t handlerPWM_pulse_10ns = {0}; // Timer 5

// USART
USART_Handler_t handlerUSART ={0};

// Variables para los comandos
char bufferReception[64];
uint8_t counterReception = 0;
uint8_t doneTransaction = RESET;
uint8_t rxData = '\0';
char cmd[32];
unsigned int firstParameter;
unsigned int secondParameter;
unsigned int thirdParameter;
char userMsg[64];
char bufferMsg[64];

//Contador
double counter = 5;

int main(void)
{
	//Activamos la FPU
	SCB -> CPACR |= (0xF << 20);

	inSystem ();

    /* Loop forever */
	while(1){


			if (rxData != '\0'){

				writeChar(&handlerUSART, rxData);

				if (rxData == '+'){

					if (counter < 100){
					counter+= 0.002;
					}else{
						counter = 100;
					}
					updateDuttyCycle(&handlerPWM_pulse_10ns, counter);
					rxData = '\0';

				}else if (rxData == '-'){

					if (counter > 0){
						counter-= 0.002;
					}else{
						counter = 0;
					}
					updateDuttyCycle(&handlerPWM_pulse_10ns, counter);
					rxData = '\0';
				}
		}
	}
}


void inSystem (void){


	// Activamos la maxima velocidad del microcontrolador
//	show_MaxFreq(MCO2,5); // Sale por el pin A8
	RCC_enableMaxFrequencies(RCC_100MHz);

	//Config del pin A8 salida de la velocidad del micro

	handlerMCOShow.pGPIOx                             = GPIOC;
	handlerMCOShow.GPIO_PinConfig.GPIO_PinNumber      = PIN_9 ;
	handlerMCOShow.GPIO_PinConfig.GPIO_PinAltFunMode  = AF0;
	handlerMCOShow.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	GPIO_Config(&handlerMCOShow);

	//BLINKY LED

	handlerPinA5.pGPIOx = GPIOA;
	handlerPinA5.GPIO_PinConfig.GPIO_PinAltFunMode = AF0;
	handlerPinA5.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	handlerPinA5.GPIO_PinConfig.GPIO_PinOPType = GPIO_OTYPE_PUSHPULL;
	handlerPinA5.GPIO_PinConfig.GPIO_PinNumber = PIN_5;
	handlerPinA5.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinA5.GPIO_PinConfig.GPIO_PinSpeed = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerPinA5);
	GPIO_WritePin(&handlerPinA5, SET);

	handlerTimerBlinky.ptrTIMx                           = TIM2;
	handlerTimerBlinky.TIMx_Config.TIMx_interruptEnable  = BTIMER_ENABLE_INTERRUPT;
	handlerTimerBlinky.TIMx_Config.TIMx_mode             = BTIMER_MODE_UP;
	handlerTimerBlinky.TIMx_Config.TIMx_speed            = BTIMER_SPEED_100MHz_10us;
	handlerTimerBlinky.TIMx_Config.TIMx_period           = 1000;
	BasicTimer_Config(&handlerTimerBlinky);
	startTimer(&handlerTimerBlinky);

	// PWM handler del GPIO y el PWM

	handlerPinPwm_pulse_10ns.pGPIOx                             = GPIOA;
	handlerPinPwm_pulse_10ns.GPIO_PinConfig.GPIO_PinAltFunMode  = AF1;
	handlerPinPwm_pulse_10ns.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handlerPinPwm_pulse_10ns.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerPinPwm_pulse_10ns.GPIO_PinConfig.GPIO_PinNumber      = PIN_8;
	handlerPinPwm_pulse_10ns.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinPwm_pulse_10ns.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_HIGH;
	GPIO_Config(&handlerPinPwm_pulse_10ns);

	handlerPWM_pulse_10ns.ptrTIMx            = TIM1;
	handlerPWM_pulse_10ns.config.channel     = PWM_CHANNEL_1;
	handlerPWM_pulse_10ns.config.duttyCicle  = 5;
	counter = handlerPWM_pulse_10ns.config.duttyCicle;
	handlerPWM_pulse_10ns.config.periodo     = 10000; // se maneja 100kHz por testeo
	handlerPWM_pulse_10ns.config.prescaler   = PWM_SPEED_100MHz_10ns;
	handlerPWM_pulse_10ns.config.polarity    = PWM_DISABLE_POLARITY;
	handlerPWM_pulse_10ns.config.optocoupler = PWM_DISABLE_OPTOCOUPLER;
	pwm_Config(&handlerPWM_pulse_10ns);
	startPwmSignal(&handlerPWM_pulse_10ns);
	enableOutput(&handlerPWM_pulse_10ns);


	//Comunicacion serial


	handlerRxPin.pGPIOx                             = GPIOA;
	handlerRxPin.GPIO_PinConfig.GPIO_PinAltFunMode  = AF7;
	handlerRxPin.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handlerRxPin.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerRxPin.GPIO_PinConfig.GPIO_PinNumber      = PIN_3;
	handlerRxPin.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerRxPin.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_HIGH;
	GPIO_Config(&handlerRxPin);


	handlerTxPin.pGPIOx                             = GPIOA;
	handlerTxPin.GPIO_PinConfig.GPIO_PinAltFunMode  = AF7;
	handlerTxPin.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handlerTxPin.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerTxPin.GPIO_PinConfig.GPIO_PinNumber      = PIN_2;
	handlerTxPin.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerTxPin.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_HIGH;
	GPIO_Config(&handlerTxPin);

	handlerUSART.ptrUSARTx                      = USART2;
	handlerUSART.USART_Config.USART_MCUvelocity = USART_50MHz_VELOCITY;
	handlerUSART.USART_Config.USART_baudrate    = USART_BAUDRATE_19200;
	handlerUSART.USART_Config.USART_enableInRx  = USART_INTERRUPT_RX_ENABLE;
	handlerUSART.USART_Config.USART_enableInTx  = USART_INTERRUPT_TX_DISABLE;
	handlerUSART.USART_Config.USART_mode        = USART_MODE_RXTX;
	handlerUSART.USART_Config.USART_parity      = USART_PARITY_NONE;
	handlerUSART.USART_Config.USART_stopbits    = USART_STOPBIT_1;
	handlerUSART.USART_Config.USART_datasize    = USART_DATASIZE_8BIT;
	USART_Config(&handlerUSART);

}

void BasicTimer2_Callback(void){
	GPIOxTooglePin(&handlerPinA5);
}

void usart2Rx_Callback(void){
	rxData = getRxData();
}



