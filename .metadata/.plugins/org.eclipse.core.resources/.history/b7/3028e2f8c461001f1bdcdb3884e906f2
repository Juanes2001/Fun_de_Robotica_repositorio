 /**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stm32f4xx.h>

#include <stdint.h>
#include "FreeRTOS.h"
#include "task.h"
#include <stdbool.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>  // for usleep


#include "GPIOxDriver.h"
#include "BasicTimer.h"
#include "USARTxDriver.h"
#include "RCCHunMHz.h"
#include "Astar.h"

void inSystem (void);
void parseCommands(char *stringVector);



//Definición Handlers
//GPIO
//Pin del User blinky
GPIO_Handler_t handlerPinA5         = {0};

//Pines de comunicacion USART
GPIO_Handler_t handlerPinRx         = {0};
GPIO_Handler_t handlerPinTx         = {0};

//Pin para visualizar la velocidad del micro
GPIO_Handler_t handlerMCO2Show      = {0};

//Timers
BasicTimer_Handler_t handlerTimerBlinky = {0}; // Timer 3

//Usart
USART_Handler_t handlerUSART = {0};

// Astar
AStar_distancesHandler handlerAstarParameters = {0};
costChangesAndPos_t handlerCostsAstar         = {0};

// Variables para los comandos
char bufferReception[64];
uint8_t counterReception = 0;
uint8_t doneTransaction = RESET;
uint8_t rxData = '\0';
char cmd[32];
unsigned int firstParameter;
unsigned int secondParameter;
unsigned int thirdParameter;
char userMsg[64];
char bufferMsg[64];

// Definición de la matriz de string que almacenará
char **stringMatrix;
float ***costs;
// Matriz donde se copiará la matriz que se inserta desde la terminal.
char **readableGrid;
// Matriz donde se almacenara las posicones de la ruta mas corta
int **shorterWay;
uint8_t stringColumn = 0;
uint8_t stringRow = 0;

// Banderas
uint8_t flagAstar   = RESET;
uint8_t starWorking = RESET;

//Mensajes
const char* msg_NotWorking = "--------Astar isn't working properly---------- ";


int main(void)
{


	//Activamos el FPU o la unidad de punto flotante
 	SCB -> CPACR |= (0xF << 20);



	inSystem ();


    /* Loop forever */
	while(1){

		if (!flagAstar){

			if (rxData != '\0'){
				bufferReception[counterReception] = rxData;
				counterReception++;

				if (rxData == '@'){
					doneTransaction = SET;

					bufferReception[counterReception-1] = '\0';

					counterReception = 0;

				}

				rxData = '\0';

			}

			if (doneTransaction){
				parseCommands(bufferReception);
				doneTransaction = RESET;
			}
		}else{
			// Si estamos aqui es porque se aplicara el mismo metodo para guardar cada fila de strings

			if (rxData != '\0'){

				if (rxData != '%'){
					stringMatrix[stringRow][stringColumn] = rxData;
					stringColumn++;
				}else{
					stringRow++;
					stringColumn = 0;
				}

				if (rxData == '@'){
					doneTransaction = SET;

					stringMatrix[stringRow][stringColumn - 1] = '\0';

					stringColumn = 0;

				}

				rxData = '\0';

			}

			if (doneTransaction){

				starWorking = findShorterWay(stringMatrix, readableGrid, costs, &handlerAstarParameters, &handlerCostsAstar, shorterWay);

				if (starWorking){

				}else{
					writeMsg(&handlerUSART, msg_NotWorking);
				}


				doneTransaction = RESET;
			}

		}
	}
}


void inSystem (void){


	// Activamos la maxima velocidad del microcontrolador
	RCC_enableMaxFrequencies();
	//Config del pin A8 salida de la velocidad del micro

//	handlerMCO2Show.pGPIOx                             = GPIOC;
//	handlerMCO2Show.GPIO_PinConfig.GPIO_PinNumber      = PIN_9 ;
//	handlerMCO2Show.GPIO_PinConfig.GPIO_PinAltFunMode  = AF0;
//	handlerMCO2Show.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
//	GPIO_Config(&handlerMCO2Show);

	//BLINKY LED

	handlerPinA5.pGPIOx = GPIOA;
	handlerPinA5.GPIO_PinConfig.GPIO_PinAltFunMode = AF0;
	handlerPinA5.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	handlerPinA5.GPIO_PinConfig.GPIO_PinOPType = GPIO_OTYPE_PUSHPULL;
	handlerPinA5.GPIO_PinConfig.GPIO_PinNumber = PIN_5;
	handlerPinA5.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinA5.GPIO_PinConfig.GPIO_PinSpeed = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerPinA5);
	GPIO_WritePin(&handlerPinA5, SET);

	handlerTimerBlinky.ptrTIMx                           = TIM3;
	handlerTimerBlinky.TIMx_Config.TIMx_interruptEnable  = BTIMER_ENABLE_INTERRUPT;
	handlerTimerBlinky.TIMx_Config.TIMx_mode             = BTIMER_MODE_UP;
	handlerTimerBlinky.TIMx_Config.TIMx_speed            = BTIMER_SPEED_100MHz_100us;
	handlerTimerBlinky.TIMx_Config.TIMx_period           = 1000;
	BasicTimer_Config(&handlerTimerBlinky);
	startTimer(&handlerTimerBlinky);



	//////////////////////////////////////////////////// /////////////////// //////////////////////////////////////////////

	///////////////////////////////////////////Comunicación serial para comandos //////////////////////////////////////////////


	//Comunicacion serial

	handlerPinRx.pGPIOx                             = GPIOA;
	handlerPinRx.GPIO_PinConfig.GPIO_PinAltFunMode  = AF7;
	handlerPinRx.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handlerPinRx.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerPinRx.GPIO_PinConfig.GPIO_PinNumber      = PIN_3;
	handlerPinRx.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinRx.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_HIGH;
	GPIO_Config(&handlerPinRx);

	handlerPinTx.pGPIOx                             = GPIOA;
	handlerPinTx.GPIO_PinConfig.GPIO_PinAltFunMode  = AF7;
	handlerPinTx.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handlerPinTx.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerPinTx.GPIO_PinConfig.GPIO_PinNumber      = PIN_2;
	handlerPinTx.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinTx.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_HIGH;
	GPIO_Config(&handlerPinTx);

	handlerUSART.ptrUSARTx                      = USART2;
	handlerUSART.USART_Config.USART_MCUvelocity = USART_50MHz_VELOCITY;
	handlerUSART.USART_Config.USART_baudrate    = USART_BAUDRATE_19200;
	handlerUSART.USART_Config.USART_enableInRx  = USART_INTERRUPT_RX_ENABLE;
	handlerUSART.USART_Config.USART_enableInTx  = USART_INTERRUPT_TX_DISABLE;
	handlerUSART.USART_Config.USART_mode        = USART_MODE_RXTX;
	handlerUSART.USART_Config.USART_parity      = USART_PARITY_NONE;
	handlerUSART.USART_Config.USART_stopbits    = USART_STOPBIT_1;
	handlerUSART.USART_Config.USART_datasize    = USART_DATASIZE_8BIT;
	USART_Config(&handlerUSART);


}


void parseCommands(char *stringVector){

	sscanf(stringVector, "%s %u %u %u %s", cmd ,&firstParameter, &secondParameter, &thirdParameter, userMsg);


	if (strcmp(cmd, "help") == 0){

		writeMsg(&handlerUSART, "HELP MENU CMD : \n");
		writeMsg(&handlerUSART, "1)  astar #parallel Distance #diagonal Distance  \n");

	}else if (strcmp(cmd, "astar") == 0){

		//////////////////////////////////////////////  ASTAR - Algoritm setup//////////////////////////////////////////////////////////

		// Solo necesitamos definir las distancias paralela y diagonal de la malla
		handlerAstarParameters.parallelDistance  = firstParameter;
		handlerAstarParameters.diagonalDiastance = secondParameter;

		flagAstar = SET;

	}



}


// Interrupcion usart 1
void usart2Rx_Callback(void){

	rxData = getRxData();

}

//Interrupción Timer 3
void BasicTimer3_Callback(void){

	GPIOxTooglePin(&handlerPinA5);

}



