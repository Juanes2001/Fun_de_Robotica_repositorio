/*
 * PwmDriver.c
 *
 *  Created on: XXXX , 2022
 *      Author: namontoy
 */
#include "PwmDriver.h"
#include "assert.h"

uint16_t periodo = 0;

/**/
void pwm_Config(PWM_Handler_t *ptrPwmHandler){

	/* 1. Activar la señal de reloj del periférico requerido */
	if (ptrPwmHandler->ptrTIMx == TIM1){
		RCC->APB2ENR |= RCC_APB2ENR_TIM1EN;

	}else if(ptrPwmHandler->ptrTIMx == TIM2){
		RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
	}
	else if(ptrPwmHandler->ptrTIMx == TIM3){
		RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;
	}
	else if(ptrPwmHandler->ptrTIMx == TIM4){
		RCC->APB1ENR |= RCC_APB1ENR_TIM4EN;
	}
	else if(ptrPwmHandler->ptrTIMx == TIM5){
		RCC->APB1ENR |= RCC_APB1ENR_TIM5EN;
	}
	else{
		__NOP();
	}



	// preguntamos si se estan usando optoacopladores

	if(ptrPwmHandler->config.optocoupler == PWM_DISABLE_OPTOCOUPLER){
		/* 1. Cargamos la frecuencia deseada */
		setFrequency(ptrPwmHandler);

		/* 2. Cargamos el valor del dutty-Cycle*/
		setDuttyCycle(ptrPwmHandler);
	}else{

		/* 1. Cargamos la frecuencia deseada */
		setFrequency(ptrPwmHandler);

		/* 2. Cargamos el valor del dutty-Cycle*/
		setDuttyCycleAfOpt(ptrPwmHandler);
	}

	/* 2a. Estamos en UP_Mode, el limite se carga en ARR y se comienza en 0 */
	ptrPwmHandler->ptrTIMx->CR1 &= ~TIM_CR1_DIR;


	ptrPwmHandler->ptrTIMx->CNT = 0;

	/* 3. Configuramos los bits CCxS del registro TIMy_CCMR1, de forma que sea modo salida
	 * (para cada canal hay un conjunto CCxS)
	 *
	 * 4. Además, en el mismo "case" podemos configurar el modo del PWM, su polaridad...
	 *
	 * 5. Y además activamos el preload bit, para que cada vez que exista un update-event
	 * el valor cargado en el CCRx será recargado en el registro "shadow" del PWM */
	switch(ptrPwmHandler->config.channel){
	case PWM_CHANNEL_1:{
		// Seleccionamos como salida el canal
		ptrPwmHandler->ptrTIMx->CCMR1 &= ~TIM_CCMR1_CC1S;

		// Configuramos el canal como PWM
		ptrPwmHandler->ptrTIMx->CCMR1 |= TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_2;

		// Activamos la funcionalidad de pre-load
		ptrPwmHandler->ptrTIMx->CCMR1 |= TIM_CCMR1_OC1PE;


		break;
	}

	case PWM_CHANNEL_2:{
		// Seleccionamos como salida el canal
		ptrPwmHandler->ptrTIMx->CCMR1 &= ~TIM_CCMR1_CC2S;

		// Configuramos el canal como PWM
		ptrPwmHandler->ptrTIMx->CCMR1 |= TIM_CCMR1_OC2M_1 | TIM_CCMR1_OC2M_2;

		// Activamos la funcionalidad de pre-load
		ptrPwmHandler->ptrTIMx->CCMR1 |= TIM_CCMR1_OC2PE;

		break;
	}

	case PWM_CHANNEL_3:{
			// Seleccionamos como salida el canal
		ptrPwmHandler->ptrTIMx->CCMR2 &= ~TIM_CCMR2_CC3S;

		// Configuramos el canal como PWM
		ptrPwmHandler->ptrTIMx->CCMR2 |= TIM_CCMR2_OC3M_1 | TIM_CCMR2_OC3M_2;

		// Activamos la funcionalidad de pre-load
		ptrPwmHandler->ptrTIMx->CCMR2 |= TIM_CCMR2_OC3PE;

		break;
	}
	case PWM_CHANNEL_4:{
			// Seleccionamos como salida el canal
		ptrPwmHandler->ptrTIMx->CCMR2 &= ~TIM_CCMR2_CC4S;

		// Configuramos el canal como PWM
		ptrPwmHandler->ptrTIMx->CCMR2 |= TIM_CCMR2_OC4M_1 | TIM_CCMR2_OC4M_2;

		// Activamos la funcionalidad de pre-load
		ptrPwmHandler->ptrTIMx->CCMR2 |= TIM_CCMR2_OC4PE;

		break;
	}

	default:{
		break;
	}

	/* 6. Activamos la salida seleccionada */

	}// fin del switch-case




}

/* Función para activar el Timer y activar todo el módulo PWM */
void startPwmSignal(PWM_Handler_t *ptrPwmHandler) {
	ptrPwmHandler->ptrTIMx->CR1 |= TIM_CR1_CEN;

}

/* Función para desactivar el Timer y detener todo el módulo PWM*/
void stopPwmSignal(PWM_Handler_t *ptrPwmHandler) {
	ptrPwmHandler->ptrTIMx->CR1 &= ~TIM_CR1_CEN;
}

/* Función encargada de activar cada uno de los canales con los que cuenta el TimerX */
uint8_t enableOutput(PWM_Handler_t *ptrPwmHandler) {
	switch (ptrPwmHandler->config.channel) {
	case PWM_CHANNEL_1: {
		// Activamos la salida del canal 1
		ptrPwmHandler->ptrTIMx->CCER |= TIM_CCER_CC1E;

		break;
	}

	case PWM_CHANNEL_2: {
		// Activamos la salida del canal 2
		ptrPwmHandler->ptrTIMx->CCER |= TIM_CCER_CC2E;

		break;
	}

	case PWM_CHANNEL_3: {
		// Activamos la salida del canal 3
		ptrPwmHandler->ptrTIMx->CCER |= TIM_CCER_CC3E;

		break;
	}

	case PWM_CHANNEL_4: {
		// Activamos la salida del canal 4
		ptrPwmHandler->ptrTIMx->CCER |= TIM_CCER_CC4E;

		break;
	}

	default: {
		break;
	}
	}

	return SET;
}

/* 
 * La frecuencia es definida por el conjunto formado por el preescaler (PSC)
 * y el valor límite al que llega el Timer (ARR), con estos dos se establece
 * la frecuencia.
 * */
void setFrequency(PWM_Handler_t *ptrPwmHandler){

	uint32_t speed   = 0;

	// Cargamos el valor del prescaler, nos define la velocidad (en ns) a la cual
	// se incrementa el Timer
	ptrPwmHandler->ptrTIMx->PSC = ptrPwmHandler->config.prescaler;

	speed = ptrPwmHandler->config.prescaler;

	// Cargamos el valor del ARR, el cual es el límite de incrementos del Timer
	// antes de hacer un update y reload.


	if  ((speed == PWM_SPEED_16MHz_1us ) || (speed == PWM_SPEED_100MHz_1us)) {

		periodo = ptrPwmHandler->config.periodo * 1000  ;

		ptrPwmHandler->ptrTIMx->ARR = periodo - 1;


	}else if ((speed == PWM_SPEED_16MHz_10us ) || (speed == PWM_SPEED_100MHz_10us)){

		periodo = ptrPwmHandler->config.periodo * 100  ;

		ptrPwmHandler->ptrTIMx->ARR = periodo - 1;

	}else if ((speed == PWM_SPEED_16MHz_100us ) || (speed == PWM_SPEED_100MHz_100us)){

		periodo = ptrPwmHandler->config.periodo * 10  ;

		ptrPwmHandler->ptrTIMx->ARR = periodo - 1;


	}else if ((speed == PWM_SPEED_16MHz_1ms )){

		periodo = ptrPwmHandler->config.periodo   ;

		ptrPwmHandler->ptrTIMx->ARR = periodo - 1;

	}

}


/* Función para actualizar la frecuencia, funciona de la mano con setFrequency */
void updateFrequency(PWM_Handler_t *ptrPwmHandler, uint16_t newPer){
	// Actualizamos el registro que manipula el periodo

	ptrPwmHandler->config.periodo = newPer;


	// Llamamos a la fucnión que cambia la frecuencia
	setFrequency(ptrPwmHandler);
}

/* El valor del dutty debe estar dado en valores de %, entre 0% y 100%*/
void setDuttyCycle(PWM_Handler_t *ptrPwmHandler){
	assert();

	// Seleccionamos el canal para configurar su dutty
	switch(ptrPwmHandler->config.channel){
	case PWM_CHANNEL_1:{
		long op = 0;
		op = (ptrPwmHandler->config.duttyCicle) * periodo;
		ptrPwmHandler->ptrTIMx->CCR1 = (op)/100;
		break;
	}

	case PWM_CHANNEL_2:{
		double op = (ptrPwmHandler->config.duttyCicle) * periodo;
		ptrPwmHandler->ptrTIMx->CCR2 = (op)/100;
		break;
	}

	case PWM_CHANNEL_3:{
		double op = (ptrPwmHandler->config.duttyCicle) * periodo;
		ptrPwmHandler->ptrTIMx->CCR3 = (op)/100;
		break;
	}

	case PWM_CHANNEL_4:{
		double op = (ptrPwmHandler->config.duttyCicle) * periodo;
		ptrPwmHandler->ptrTIMx->CCR4 = (op)/100;
		break;
	}

	default:{
		break;
	}

	}// fin del switch-case

}


void setDuttyCycleAfOpt(PWM_Handler_t *ptrPwmHandler){

	// Seleccionamos el canal para configurar su dutty
	switch(ptrPwmHandler->config.channel){
	case PWM_CHANNEL_1:{
		double op = (100-ptrPwmHandler->config.duttyCicle) * periodo;
		ptrPwmHandler->ptrTIMx->CCR1 = (op)/100;
		break;
	}

	case PWM_CHANNEL_2:{
		double op = (100-ptrPwmHandler->config.duttyCicle) * periodo;
		ptrPwmHandler->ptrTIMx->CCR2 = (op)/100;
		break;
	}

	case PWM_CHANNEL_3:{
		double op = (100-ptrPwmHandler->config.duttyCicle) * periodo;
		ptrPwmHandler->ptrTIMx->CCR3 = (op)/100;
		break;
	}

	case PWM_CHANNEL_4:{
		double op = (100-ptrPwmHandler->config.duttyCicle) * periodo;
		ptrPwmHandler->ptrTIMx->CCR4 = (op)/100;
		break;
	}

	default:{
		break;
	}

	}// fin del switch-case


}

uint8_t showPWM (PWM_Handler_t *ptrPwmHandler){

	uint8_t PWMdutty = 0;

	// Seleccionamos el canal para configurar su dutty
	switch(ptrPwmHandler->config.channel){
	case PWM_CHANNEL_1:{

		PWMdutty = (ptrPwmHandler->ptrTIMx->CCR1)*100 / periodo;
		break;
	}

	case PWM_CHANNEL_2:{
		PWMdutty = (ptrPwmHandler->ptrTIMx->CCR2)*100 / periodo;
		break;
	}

	case PWM_CHANNEL_3:{
		PWMdutty = (ptrPwmHandler->ptrTIMx->CCR3)*100 / periodo;
		break;
	}

	case PWM_CHANNEL_4:{
		PWMdutty = (ptrPwmHandler->ptrTIMx->CCR4)*100 / periodo;
		break;
	}

	default:{
		break;
	}

	}// fin del switch-case

	return PWMdutty;

}

uint8_t showPWMBfOpt (PWM_Handler_t *ptrPwmHandler){

	uint8_t PWMdutty = 0;

	// Seleccionamos el canal para configurar su dutty
	switch(ptrPwmHandler->config.channel){
	case PWM_CHANNEL_1:{

		PWMdutty = 100-(ptrPwmHandler->ptrTIMx->CCR1)*100 / periodo;
		break;
	}

	case PWM_CHANNEL_2:{
		PWMdutty = 100-(ptrPwmHandler->ptrTIMx->CCR2)*100 / periodo;
		break;
	}

	case PWM_CHANNEL_3:{
		PWMdutty = 100-(ptrPwmHandler->ptrTIMx->CCR3)*100 / periodo;
		break;
	}

	case PWM_CHANNEL_4:{
		PWMdutty = 100-(ptrPwmHandler->ptrTIMx->CCR4)*100 / periodo;
		break;
	}

	default:{
		break;
	}

	}// fin del switch-case

	return PWMdutty;

}


/* Función para actualizar el Dutty, funciona de la mano con setDuttyCycle */
void updateDuttyCycle(PWM_Handler_t *ptrPwmHandler, float newDutty){
	// Actualizamos el registro que manipula el dutty
    ptrPwmHandler->config.duttyCicle = newDutty;

	// Llamamos a la fucnión que cambia el dutty y cargamos el nuevo valor
    setDuttyCycle(ptrPwmHandler);
}


void updateDuttyCycleAfOpt(PWM_Handler_t *ptrPwmHandler, float newDutty){

	// Actualizamos el registro que manipula el dutty
	ptrPwmHandler->config.duttyCicle = newDutty;

	// Llamamos a la fucnión que cambia el dutty y cargamos el nuevo valor
	setDuttyCycleAfOpt(ptrPwmHandler);

}

void enableEvent(PWM_Handler_t *ptrPwmHandler){
	switch (ptrPwmHandler->config.channel){
	case PWM_CHANNEL_1: {
		ptrPwmHandler->ptrTIMx->EGR |= TIM_EGR_CC1G;
		break;
	}
	case PWM_CHANNEL_2: {
		ptrPwmHandler->ptrTIMx->EGR |= TIM_EGR_CC2G;
		break;
	}
	case PWM_CHANNEL_3: {
		ptrPwmHandler->ptrTIMx->EGR |= TIM_EGR_CC3G;
		break;
	}
	case PWM_CHANNEL_4: {
		ptrPwmHandler->ptrTIMx->EGR |= TIM_EGR_CC4G;
		break;
	}
	default:{
		break;
	}
	}
}

void disableEvent(PWM_Handler_t *ptrPwmHandler){
	switch (ptrPwmHandler->config.channel){
		case PWM_CHANNEL_1: {
			ptrPwmHandler->ptrTIMx->EGR &= ~TIM_EGR_CC1G;
			break;
		}
		case PWM_CHANNEL_2: {
			ptrPwmHandler->ptrTIMx->EGR &= ~TIM_EGR_CC2G;
			break;
		}
		case PWM_CHANNEL_3: {
			ptrPwmHandler->ptrTIMx->EGR &= ~TIM_EGR_CC3G;
			break;
		}
		case PWM_CHANNEL_4: {
			ptrPwmHandler->ptrTIMx->EGR &= ~TIM_EGR_CC4G;
			break;
		}
		default:{
			break;
		}
		}
}


uint8_t disableOutput(PWM_Handler_t *ptrPwmHandler){

	switch (ptrPwmHandler->config.channel) {
		case PWM_CHANNEL_1: {
			// Activamos la salida del canal 1
			ptrPwmHandler->ptrTIMx->CCER &= ~TIM_CCER_CC1E;

			break;
		}

		case PWM_CHANNEL_2: {
			// Activamos la salida del canal 2
			ptrPwmHandler->ptrTIMx->CCER &= ~TIM_CCER_CC2E;

			break;
		}

		case PWM_CHANNEL_3: {
			// Activamos la salida del canal 3
			ptrPwmHandler->ptrTIMx->CCER &= ~TIM_CCER_CC3E;

			break;
		}

		case PWM_CHANNEL_4: {
			// Activamos la salida del canal 4
			ptrPwmHandler->ptrTIMx->CCER &= ~TIM_CCER_CC4E;

			break;
		}

		default: {
			break;
		}
		}

	return RESET;
}

void PWMx_Toggle(PWM_Handler_t *ptrPwmHandler){

	switch (ptrPwmHandler->config.channel) {
			case PWM_CHANNEL_1: {
				// Activamos el polarity en este canal
				ptrPwmHandler->ptrTIMx->CCER ^= TIM_CCER_CC1P;

				break;
			}

			case PWM_CHANNEL_2: {
				// Activamos el polarity en este canal
				ptrPwmHandler->ptrTIMx->CCER ^= TIM_CCER_CC2P;

				break;
			}

			case PWM_CHANNEL_3: {
				// Activamos el polarity en este canal
				ptrPwmHandler->ptrTIMx->CCER ^= TIM_CCER_CC3P;

				break;
			}

			case PWM_CHANNEL_4: {
				// Activamos el polarity en este canal
				ptrPwmHandler->ptrTIMx->CCER ^= TIM_CCER_CC4P;

				break;
			}

			default: {
				break;
			}
			}


}



