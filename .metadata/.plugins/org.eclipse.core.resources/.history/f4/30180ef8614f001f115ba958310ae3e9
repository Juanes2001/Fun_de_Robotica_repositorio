/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stm32f4xx.h>

#include <stdint.h>
#include "FreeRTOS.h"
#include "task.h"
#include <stdbool.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include "GPIOxDriver.h"
#include "BasicTimer.h"
#include "PwmDriver.h"
#include "EXTIDriver.h"
#include "RCCHunMHz.h"

/*definicion de variables del sistema*/


#define STACK_SIZE 200

uint32_t SystemCoreClock = 100000000;
/*Cabecera de la funcion de tarea 1 */
void vTaskLedGreen( void * pvParameters );

TaskHandle_t xHandleTask_Led    = NULL;
TaskHandle_t xHandleTask_Button = NULL;

void vTaskTwo( void * pvParameters );
void inSystem (void);
void parseCommands(char *stringVector);

//DefiniciÃ³n Handlers
//GPIO
GPIO_Handler_t handlerPinA5           = {};
GPIO_Handler_t handlerUserButton      = {};
EXTI_Config_t  handler_exti_userButon = {};

//Timers
BasicTimer_Handler_t handlerTimerBlinky = {};

// Variables para los comandos
char bufferReception[64];
uint8_t counterReception = 0;
uint8_t doneTransaction = RESET;
uint8_t rxData = '\0';
char cmd[32];

unsigned int firstParameter;
unsigned int secondParameter;
unsigned int thirdParameter;
char userMsg[64];

int main(void)
{


	//Activamos el FPU o la unidad de punto flotante
	SCB -> CPACR |= (0xF << 20);


	//Activamos el contador
   	DWT -> CTRL    |= (1 << 0);

	// Configuracion de orden de prioridad
	//vInitPrioGroupValue();
//
//	/* Primero configuramos */
//	SEGGER_SYSVIEW_Conf();
//	/* Despues activamos el sistema */
//	SEGGER_SYSVIEW_Start();


	inSystem ();

	BaseType_t xReturned;

	xReturned = xTaskCreate(
						vTaskLedGreen,       /* Function that implements the task. */
	                    "Task-1",          /* Text name for the task. */
	                    STACK_SIZE,      /* Stack size in words, not bytes. */
						NULL,    /* Parameter passed into the task. */
	                    2,/* Priority at which the task is created. */
	                    &xHandleTask_Led );      /* Used to pass out the created task's handle. */


	 configASSERT( xReturned == pdPASS );

	 xReturned = xTaskCreate(
	 	                    vTaskTwo,       /* Function that implements the task. */
	 	                    "Task-2",          /* Text name for the task. */
	 	                    STACK_SIZE,      /* Stack size in words, not bytes. */
	 	                    "HOLA MUNDO",    /* Parameter passed into the task. */
	 	                    2,/* Priority at which the task is created. */
	 	                    &xHandleTask_Button );      /* Used to pass out the created task's handle. */


	 /* Start the created tasks running. */
	 vTaskStartScheduler();


    /* Loop forever */
	while(1){
//		GPIOxTooglePin(&handlerPinA5);
//		for (uint16_t steps = 0 ; steps < 10000 ;steps++){
//
//		}


//		if (rxData != '\0'){
//			bufferReception[counterReception] = rxData;
//			counterReception++;
//
//			if (rxData == '@'){
//				doneTransaction = SET;
//
//				bufferReception[counterReception] = '\0';
//
//				counterReception = 0;
//
//			}
//
//			rxData = '\0';
//
//		}
//
//		if (doneTransaction){
//			parseCommands(bufferReception);
//			doneTransaction = RESET;
//		}
//
		//Si se llega hasta aca es porque algo salio mal

	}
}


void inSystem (void){




	//Descripcion de la configuracion

	// Activamos la maxima velocidad del microcontrolador
	RCC_enableMaxFrequencies();

	//BLINKY LED

	handlerPinA5.pGPIOx = GPIOA;
	handlerPinA5.GPIO_PinConfig.GPIO_PinAltFunMode = AF0;
	handlerPinA5.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	handlerPinA5.GPIO_PinConfig.GPIO_PinOPType = GPIO_OTYPE_PUSHPULL;
	handlerPinA5.GPIO_PinConfig.GPIO_PinNumber = PIN_5;
	handlerPinA5.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinA5.GPIO_PinConfig.GPIO_PinSpeed = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerPinA5);
	GPIO_WritePin(&handlerPinA5, RESET);


	// USER Button exti config

	handlerUserButton.pGPIOx = GPIOC;
	handlerUserButton.GPIO_PinConfig.GPIO_PinAltFunMode = AF0;
	handlerUserButton.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN;
	handlerUserButton.GPIO_PinConfig.GPIO_PinOPType = GPIO_OTYPE_PUSHPULL;
	handlerUserButton.GPIO_PinConfig.GPIO_PinNumber = PIN_13;
	handlerUserButton.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerUserButton.GPIO_PinConfig.GPIO_PinSpeed = GPIO_OSPEEDR_FAST;
	handler_exti_userButon.edgeType = EXTERNAL_INTERRUPT_RISING_EDGE;
	handler_exti_userButon.pGPIOHandler = &handlerUserButton;
	exti_Set_Priority(&handler_exti_userButon, e_EXTI_PRIORITY_6);
	extInt_Config(&handler_exti_userButon);




}



void vTaskLedGreen( void * pvParameters )
{

   while(1){
	   //printf("%s\n",((char*) pvParameters));
	   GPIOxTooglePin(&handlerPinA5);
   	   vTaskDelay((pdMS_TO_TICKS(250)));
	   //taskYIELD();
   }
}

void vTaskTwo( void * pvParameters )
{

   while(1){
	   printf("%s\n",((char*) pvParameters));
	   vTaskDelay((pdMS_TO_TICKS(10)));
	   //GPIO_WritePin(&handlerPinA5, SET);
	   //taskYIELD();
   }
}





void parseCommands(char *stringVector){

	sscanf(stringVector, "%s %u %u %u %s", cmd ,&firstParameter, &secondParameter, &thirdParameter, userMsg);

}
