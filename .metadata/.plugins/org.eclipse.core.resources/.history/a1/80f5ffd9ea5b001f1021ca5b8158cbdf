/*
 * main4.c
 *
 *  Created on: Aug 16, 2024
 *      Author: juan
 */


#include <stm32f4xx.h>

/* Incluir las librerias de freeRTOS que sean necesarias (5)*/
#include

#include <stdint.h>
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

/* Incluir los drivers que sean necesarios (4)*/
#include

/* tamaño del stack */
#define STACK_SIZE ---

/*definicion de variables del sistema */
uint32_t SystemCoreClock = 100000000;

/* Definición de Perifericos del nuestras librerias para controlar un LED (1)*/
GPIO_Handler_t ---;

/* Definición de Periphericos del nuestras librerias para recibir una interrupcion EXTI (2)*/
-----------------(x2);

/* Definición de Periphericos del nuestras librerias para recibir el manejo del USART (3)*/
USART_Handler_t ---;

/* Definición de Variable auxiliar para la recepcion serial*/
uint8_t usartData = 0;

/* Elemento del freeRTOS con el que se recibe el resultado de la creación de
 * tareas, y otros elementos del kernel del freeRTOS (1)*/
---------------;

/* Definicion de un semaforo binario y un semaforo contador (2)*/
SemaphoreHandle_t ---;

/*  Definición de Software timer para el led de estado (1)*/
------------------;

TaskHandle_t xHandleTask_Counting = NULL;
TaskHandle_t xHandleTask_Print = NULL;

QueueHandle_t xQueue_Print;

const char *msg_working = "\n - - Working - - \n";
char auxMsg[64] = {0};
//char *dummy = auxMsg;

volatile uint8_t printOneTime = 0;

volatile uint16_t randomNumber = 0;

/* cabeceras de las funciones que representan las tareas que ejecuta el FreeRTOS (2)*/
void ------------( void * pvParameters );
void ------------( void * pvParameters );

/* Cabeceras de otras funciones, como el initsystem, la función para generar el número random
 * y el callback para el led de estado (3)*/
-----------;
uint16_t getRandomNumber(void);
-----------;

/* Funcion principal. Aca es donde sucede todo!! */
int main(void)
{
	/*Inicializacion del sistema:
	 * - Encender la FPU
	 * - Activar el contador de Ticks para debuging
	 * - Configurar adecuadamente el reloj principal del equipo para 100MHz
	 * - Lllamar a la funcion que inicializa nuestros perifericos (initSystem)
	 * */

	/* Crear las tareas que necesita el programa*/
	/* Creando la Tarea Counter */
	xReturned = xTaskCreate(---------------);

    configASSERT(xReturned == pdPASS);

    /* Creando la Tarea Print */
    xReturned = xTaskCreate(---------------);

    configASSERT(xReturned == pdPASS);

    /* Crear la cola para la tarea de impresion*/
    xQueue_Print = ---------------;
    configASSERT(xQueue_Print != NULL);  // verificamos que se ha creado la queue correctamente.

    /* Creando el semaforo binario (1)*/
   	xBinarySemaphore = ---------------------;
   	configASSERT(xBinarySemaphore != NULL);  // verificamos que se ha creado la queue correctamente.

   	/* Creando el semaforo counter de 10 elementos, que inicia en 0 (1)*/
   	xCounterSemaphore = --------------------;
   	configASSERT(xCounterSemaphore != NULL);  // verificamos que se ha creado la queue correctamente.

    /* Creando el timer que controla el blinky del led de estado, con un periodo de 350ms (1)*/
   	------------------------------------------;

   	/* Activar el Timer que controla el led (1)*/
   	-------------------------------;

    /* Start the created tasks running. */
    vTaskStartScheduler();


    /* Loop forever */
	while(1){
		/*Si llegamos aca, es que algo salio mal...*/
	}
}


/* Funcion que gobierna a la tarea que muestra como funciona un semaforo contador */
void vTask_Test_counting( void * pvParameters )
{

	const TickType_t xMaxExpectedBlockTime = pdMS_TO_TICKS( 1000 );

    while(1)
    {
    	/* En este if() el sistema espera que se tenga un elemento disponible en el semaforo
    	 * cuando esta disponible actual -> imprime un mensaje que dice "working"*/
    	if ( -------------------------------------- == pdPASS) {

    		/* Este bloque es para imprimir solo 1 vez el valor del numero aleatorio*/
    		if(printOneTime == 1){
    			sprintf(auxMsg, "counter i = %d\n", randomNumber);
    			char *dummy = auxMsg;
    			xQueueSend(xQueue_Print, &dummy, portMAX_DELAY);
    			printOneTime = 0;
    		}
    		/* Imprime las peticiones de trabajo que genera el numero aleatorio en la interupcion*/
    		-----------------;
    	}
    }
}

/* Funcion que gobierna a la tarea Print */
void vTask_Print( void * pvParameters )
{

	uint32_t *msg;
    while(1)
    {
        /* Task code goes here. */
    	xQueueReceive(xQueue_Print, &msg, portMAX_DELAY);
    	//usart_writeMsg(&commTerm_Handler, (char*)msg);
    	usart_writeMsg(&commTerm_Handler, (char*)msg);

    }
}

/* Funcion para inicializar el hardware del equipo (peripheralDrivers) */
void initSystem(void){
	/* Configurando el LED_STATE, GPIOA PIN5 (6)*/
	----------------------(x6);
	gpio_Config(&led_State_Handle);
	gpio_WritePin(&led_State_Handle, RESET);

	/* Configurando el UserButton, GPIOC PIN-13 */
	----------------------(x4);
	gpio_Config(&user_button_Handle);

	/* Matriculando el PINC3 en los elementos del EXTI, ademas de configurar la
	 * prioridad de la interrupcion (4) */
	-----------------------(x4);
	exti_Config(&exti_button_Handle);

	/* configuramos primero los pines que corresponden al USART2 */
	/* Config Rx (6)*/
	-----------------------(x6);
	gpio_Config(&PinRX_Handle);

	/* Config Tx (6)*/
	-----------------------(x6);
	gpio_Config(&pinTX_Handle);

	/* Configurando el puerto serial (7)*/
	-----------------------(x7)
	usart_Config_Int_Priority(&commTerm_Handler, e_USART_PRIORITY_6);
	usart_Config(&commTerm_Handler);


}

/*
 * Generar un numero aleatorio entre 1 y 10
 * la funcion sran(number), es para generar una semilla, de forma
 * que rand() genere un numero diferente siempre.
 * La funcion srand(number) requiere siempre un numero diferente, para
 * generar siempre un numero diferente...
 * */
uint16_t getRandomNumber(void)
{
	srand(xTaskGetTickCount());
	int randomnumber;
	randomnumber = (rand() % 10) +1;
	return (uint16_t)randomnumber;
}

/*Controla el estado del Led */
void led_state_callback( TimerHandle_t xTimer )
{
	/* Toogle LED */
}

/* Interrupcion lanzada por el encider del BlueMotor. */
void callback_ExtInt13(void)
{
	/* Activar la variable printOneTime*/
	-------------------;
	/* Generar un numero aleatorio */
	-------------------;

	BaseType_t pxHigherPriorityTaskWoken;
	pxHigherPriorityTaskWoken = pdFALSE;
	//(void)pxHigherPriorityTaskWoken;

	/* Hacer un for que se ejecute tantas veces como el numero aleatorio lo indica
	 * y allí cargar el semaforo (ejemplo binario y ejemplo counter)*/
   	for (uint16_t ii = 0; ii < randomNumber; ii++) {
   		/*cargar el semaforo e indicar que hay un cambio en las funciones.*/
   		---------------------------------;
	}
}

/* Interrupcion debida al puerto serial */
void usart2_RxCallback(void)
{
	/* Recibir un dato en el serial y no hacer nada mas*/
}
