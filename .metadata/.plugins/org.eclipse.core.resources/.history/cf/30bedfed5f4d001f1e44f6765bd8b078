 /**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stm32f4xx.h>

#include <stdint.h>
#include "FreeRTOS.h"
#include "task.h"
#include <stdbool.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include "GPIOxDriver.h"
#include "BasicTimer.h"
#include "PwmDriver.h"
#include "USARTxDriver.h"
#include "RCCHunMHz.h"
#include "EXTIDriver.h"
#include "MotorsDriver.h"
#include "I2CDriver.h"
#include "MPUAccel.h"

/*definicion de variables del sistema*/


//#define STACK_SIZE 200

//uint32_t SystemCoreClock = 100000000;
/*Cabecera de la funcion de tarea 1 */
//void vTaskOne( void * pvParameters );
//void vTaskTwo( void * pvParameters );

void inSystem (void);
void parseCommands(char *stringVector);
double distanceM1 (void);
double distanceM2 (void);
void breakMotor (void);
float calibracionGyros (MPUAccel_Config *ptrMPUAccel, uint8_t axis);

//Definición Handlers
//GPIO
//Pin del User blinky
GPIO_Handler_t handlerPinA5         = {0};

//Pin de Reset
GPIO_Handler_t handlerUserButton    = {0};


//Pines PWM que controlan la velocidad de los motores
GPIO_Handler_t handlerPinPwm_1      = {0};
GPIO_Handler_t handlerPinPwm_2      = {0};

//Pines de comunicacion USART
GPIO_Handler_t handlerPinRx         = {0};
GPIO_Handler_t handlerPinTx         = {0};

//Pin para visualizar la velocidad del micro
GPIO_Handler_t handlerMCO2Show      = {0};

//Pines para encendido y apagado de los motores
GPIO_Handler_t handlerEn2PinC11     = {0};
GPIO_Handler_t handlerEn1PinC10     = {0};

//Pines de salida para la direccion de las ruedas
GPIO_Handler_t handlerIn2PinD2      = {0};
GPIO_Handler_t handlerIn1PinC12     = {0};

//Pines para lectura de encoders
GPIO_Handler_t handlerEncoder1PinC1 = {0};
GPIO_Handler_t handlerEncoder2PinC3 = {0};

// Pines para I2C1
GPIO_Handler_t handler_PINB8_I2C1   = {0};
GPIO_Handler_t handler_PINB9_I2C1   = {0};

//Extis
EXTI_Config_t handlerExtiConEnc_1 = {0};
EXTI_Config_t handlerExtiConEnc_2 = {0};

//Timers
BasicTimer_Handler_t handlerTimerBlinky = {0}; // Timer 3
BasicTimer_Handler_t handlerTIM2_vel    = {0}; // Timer 2
BasicTimer_Handler_t handlerTIM4_time   = {0}; // Timer 4

//PWMs
PWM_Handler_t handlerPWM_1 = {0}; // Timer 5
PWM_Handler_t handlerPWM_2 = {0}; // Timer 5

//Usart
USART_Handler_t handlerUSART1 = {0};


//Motores
Motor_Handler_t handlerMotor1 = {0};
Motor_Handler_t handlerMotor2 = {0};

//I2C
I2C_Handler_t handler_I2C1 = {0};

//MPUAccel
MPUAccel_Config handler_MPUAccel_6050 ={0};


// Variables para los comandos
char bufferReception[64];
uint8_t counterReception = 0;
uint8_t doneTransaction = RESET;
uint8_t rxData = '\0';
char cmd[32];
unsigned int firstParameter;
unsigned int secondParameter;
unsigned int thirdParameter;
char userMsg[64];
char bufferMsg[64];


//Banderas
uint8_t flagUart        = RESET;
uint8_t flagPWM_1       = RESET;
uint8_t flagPWM_2       = RESET;
uint8_t flagT2          = RESET;
uint8_t flagPr          = SET;
uint8_t enableChangePWM = RESET;
uint8_t flagGyro        = RESET;

//contadores
float counterPWM1      = 0;
float counterPWM2      = 0;
float counter          = 0;
uint32_t counter_M1Abs = 0;
uint32_t counter_M2Abs = 0;
double dist_1 = 0;
double dist_2 = 0;
uint16_t  controlM1      = 0;
uint16_t  controlM2      = 0;
uint16_t  controlM1_prev = 0;
uint16_t  controlM2_prev = 0;
uint16_t counterTIM3     = 0;
uint16_t counterSet      = 0;

//Velocidades
float diferenceM1  = 0;
float diferenceM2  = 0;


//Constantes
float setPoint    = 0;
uint16_t distance = 0;

//Factores de correccion
float PM1 = 0;
float PM2 = 0;

//Variables PID
float uAM1  = 0;
float uAM2  = 0;
float k     = 2;
float tau   = 200;
float theta = 150;
float Ts    = 80;

//Variables
float dps       = 0;
uint32_t tiempo = 0;
float calibr    = 0;


//Creacion de tareas

//TaskHandle_t xHandleTask1 = NULL;
//TaskHandle_t xHandleTask2 = NULL;

//extern void SEGGER_UART_init(uint32_t);

int main(void)
{


	//Activamos el FPU o la unidad de punto flotante
 	SCB -> CPACR |= (0xF << 20);




//	//Activamos el contador
//   	DWT -> CTRL    |= (1 << 0);

	// Configuracion de orden de prioridad
//	vInitPrioGroupValue();

//  SEGGER_UART_init(500000);
//	/* Primero configuramos */
//	SEGGER_SYSVIEW_Conf();
//	/* Despues activamos el sistema */
	//SEGGER_SYSVIEW_Start();


	inSystem ();

//	BaseType_t xReturned;
//
//	xReturned = xTaskCreate(
//	                    vTaskOne,       /* Function that implements the task. */
//	                    "Task-1",          /* Text name for the task. */
//	                    STACK_SIZE,      /* Stack size in words, not bytes. */
//						NULL,    /* Parameter passed into the task. */
//	                    2,/* Priority at which the task is created. */
//	                    &xHandleTask1 );      /* Used to pass out the created task's handle. */
//
//
//	 configASSERT( xReturned == pdPASS );
//
//	 xReturned = xTaskCreate(
//	 	                    vTaskTwo,       /* Function that implements the task. */
//	 	                    "Task-2",          /* Text name for the task. */
//	 	                    STACK_SIZE,      /* Stack size in words, not bytes. */
//	 	                    "HOLA MUNDO",    /* Parameter passed into the task. */
//	 	                    2,/* Priority at which the task is created. */
//	 	                    &xHandleTask2 );      /* Used to pass out the created task's handle. */
//
//
//	 /* Start the created tasks running. */
//	 vTaskStartScheduler();


    /* Loop forever */
	while(1){



//		if (rxData != '\0'){
//
//			writeChar(&handlerUSART1, rxData);
//
//			if (rxData == '+'){
//
//				if (counter < 100){
//					counter+= 1;
//				}
//				updateDuttyCycleAfOpt(&handlerPWM_1, counter);
//				updateDuttyCycleAfOpt(&handlerPWM_2, counter);
//				rxData = '\0';
//
//			}else if (rxData == '-'){
//
//				if (counter > 0){
//					counter-= 1;
//				}
//				updateDuttyCycleAfOpt(&handlerPWM_1, counter);
//				updateDuttyCycleAfOpt(&handlerPWM_2, counter);
//				rxData = '\0';
//			}else if (rxData == 'p'){
//
//				PWMx_Toggle(&handlerPWM_1);
//				rxData = '\0';
//			}else if (rxData == '1'){
//
//
//				if (!flagPWM_1){
//
//					flagPWM_1 = enableOutput(&handlerPWM_1);
//					GPIO_WritePin_Afopt (&handlerEn1PinC10,SET);
//
//				}else{
//
//					flagPWM_1 = disableOutput(&handlerPWM_1);
//					GPIO_WritePin_Afopt (&handlerEn1PinC10,RESET);
//				}
//
//
//				rxData = '\0';
//
//
//			}else if (rxData == '2'){
//
//
//				if (!flagPWM_2){
//
//					flagPWM_2 = enableOutput(&handlerPWM_2);
//					GPIO_WritePin_Afopt (&handlerEn2PinC11,SET);
//
//				}else{
//
//					flagPWM_2 = disableOutput(&handlerPWM_2);
//					GPIO_WritePin_Afopt (&handlerEn2PinC11,RESET);
//				}
//
//
//				rxData = '\0';
//
//			}
//
//
//			else{
//				rxData = '\0';
//			}
//		}




		if (rxData != '\0'){
			writeChar(&handlerUSART1, rxData);
			bufferReception[counterReception] = rxData;
			counterReception++;

			if (rxData == '@'){
				doneTransaction = SET;

				bufferReception[counterReception-1] = '\0';

				counterReception = 0;

			}else if (rxData == 'z'){

				memset(bufferReception, 0, sizeof(bufferReception));
				counterReception = 0;
				writeMsg(&handlerUSART1, "Buffer Vaciado\n \r");
			}

				rxData = '\0';

			}

		if (doneTransaction){
			parseCommands(bufferReception);
			doneTransaction = RESET;
		}


		if

		(enableChangePWM)

//		(counterPWM1 <= 100 && counterPWM2 <= 100)

//		( ( (dist_1 < distance) && (dist_2 < distance) ) )
		{


			if (flagT2){

//					updateDuttyCycleAfOpt(&handlerPWM_1, counterPWM1);
//					updateDuttyCycleAfOpt(&handlerPWM_2, counterPWM2);
//
//					controlM1 = counter_M1;
//					controlM2 = counter_M2;
//
//					diferenceM1 = abs(controlM1 - controlM1_prev);
//					diferenceM2 = abs(controlM2 - controlM2_prev);
//
//					controlM1_prev = controlM1;
//					controlM2_prev = controlM2;

//					if (diferenceM1 < diferenceM2){
//
//						counterPWM1 += 1.13; // hasta ahora el mejor ha sido 1.13
//						counterPWM2 -= 1; // hasta ahora el mejor ha sido 1
//
//					}
//
//
//					else if (diferenceM1 > diferenceM2){
//
//						counterPWM1 -= 1.11; // hasta ahora el mejor ha sido 1.1
//						counterPWM2 += 1; // hasta ahora el mejor ha sido 1
//
//					}



				controlM1 = handlerMotor1.configM1.counts_M1;
				controlM2 = handlerMotor2.configM2.counts_M2;

				diferenceM1 = abs(controlM1 - controlM1_prev);
				diferenceM2 = abs(controlM2 - controlM2_prev);

				controlM1_prev = controlM1;
				controlM2_prev = controlM2;

				uAM1 = PID(&handlerMotor1, diferenceM1, 1, setPoint);
				uAM2 = PID(&handlerMotor2, diferenceM2, 2, setPoint);

				PM1 = map(uAM1, 0 , 600 , 0, 100);
				PM2 = map(uAM2, 0 , 600 , 0, 100);

				if (PM1 < 0 || PM2 < 0){

					PM1 = 0;
					PM2 = 0;

				}else if (PM1 > 100 || PM2 > 100){

					PM1 = 100;
					PM2 = 100;
				}

				dist_1 = distanceM1();
				dist_2 = distanceM2();

				updateDuttyCycleAfOpt(&handlerPWM_1, PM1);
				updateDuttyCycleAfOpt(&handlerPWM_2, PM2);

				sprintf (bufferMsg, //"%u\t%u\t%.3f\t%.3f\t

						//"%u\t%u\t"

						"%.3f\t%.3f\t%.3f\t%.3f\t%.3f\n",

						PM1, PM2, diferenceM1, diferenceM2, setPoint

						// counter_M1, counter_M2,

//						 counterPWM1, diferenceM1, diferenceM2
						//, dist_1 ,dist_2
						);
				writeMsg(&handlerUSART1, bufferMsg);

//				counterPWM1 += 0.1;
//				counterPWM2 += 0.1;



				flagT2 = RESET;

			}

		}else if (flagGyro){

			dps = readGyro_Z (&handler_MPUAccel_6050);
			dps -= calibr;
			sprintf (bufferMsg, //"%u\t%u\t%.3f\t%.3f\t

			//"%u\t%u\t"

			"%.3f\n",

			dps

			// counter_M1, counter_M2,

	//					counterPWM1, diferenceM1, diferenceM2
			//, dist_1 ,dist_2
			);
			writeMsg(&handlerUSART1, bufferMsg);

			flagGyro = RESET;

		}


		else{

		//	breakMotor();

		}




//		for (uint8_t i = 0; i<=4; i++){
//
//			promCountsM1 += promCountsM12[0][i];
//			promCountsM2 += promCountsM12[1][i];
//
//			if (i == 4){
//
//				promedioM1  = promCountsM1 / 5;
//				promedioM2  = promCountsM2 / 5;
//
//				promCountsM1 = 0;
//				promCountsM2 = 0;
//
//			}
//
//		}

//		if (enableChangePWM){
//
//			diferenceM1 =  setPoint - controlM1;
//			diferenceM2 =  setPoint - controlM2;
//
//			PM1 = Kp * diferenceM1;
//			PM2 = Kp * diferenceM2;
//
//
//			if (abs(PM1) > 3){
//
//				counterPWM1 = map(PM1, -100, 100, 20, 50);
//
//				updateDuttyCycleAfOpt(&handlerPWM_1, counterPWM1);
//
//			}
//
//			if (abs(PM2) > 3){
//
//				counterPWM2 = map(PM2, -100, 100, 20, 34);
//
//				updateDuttyCycleAfOpt(&handlerPWM_2, counterPWM2);
//
//			}
//
//
//
//		}


	}
}


void inSystem (void){


	// Activamos la maxima velocidad del microcontrolador
	RCC_enableMaxFrequencies();
	//Config del pin A8 salida de la velocidad del micro

//	handlerMCO2Show.pGPIOx                             = GPIOC;
//	handlerMCO2Show.GPIO_PinConfig.GPIO_PinNumber      = PIN_9 ;
//	handlerMCO2Show.GPIO_PinConfig.GPIO_PinAltFunMode  = AF0;
//	handlerMCO2Show.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
//	GPIO_Config(&handlerMCO2Show);

	//BLINKY LED

	handlerPinA5.pGPIOx = GPIOA;
	handlerPinA5.GPIO_PinConfig.GPIO_PinAltFunMode = AF0;
	handlerPinA5.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	handlerPinA5.GPIO_PinConfig.GPIO_PinOPType = GPIO_OTYPE_PUSHPULL;
	handlerPinA5.GPIO_PinConfig.GPIO_PinNumber = PIN_5;
	handlerPinA5.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinA5.GPIO_PinConfig.GPIO_PinSpeed = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerPinA5);
	GPIO_WritePin(&handlerPinA5, SET);

	handlerTimerBlinky.ptrTIMx                           = TIM3;
	handlerTimerBlinky.TIMx_Config.TIMx_interruptEnable  = BTIMER_ENABLE_INTERRUPT;
	handlerTimerBlinky.TIMx_Config.TIMx_mode             = BTIMER_MODE_UP;
	handlerTimerBlinky.TIMx_Config.TIMx_speed            = BTIMER_SPEED_100MHz_100us;
	handlerTimerBlinky.TIMx_Config.TIMx_period           = 1000;
	BasicTimer_Config(&handlerTimerBlinky);
	startTimer(&handlerTimerBlinky);


	//////////////////////////////////////////////////// Velocidad de motores //////////////////////////////////////////////


	//PWM
	// PWM motor 1
	handlerPinPwm_1.pGPIOx                             = GPIOA;
	handlerPinPwm_1.GPIO_PinConfig.GPIO_PinAltFunMode  = AF2;
	handlerPinPwm_1.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handlerPinPwm_1.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerPinPwm_1.GPIO_PinConfig.GPIO_PinNumber      = PIN_0;
	handlerPinPwm_1.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinPwm_1.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerPinPwm_1);

	handlerPWM_1.ptrTIMx            = TIM5;
	handlerPWM_1.config.channel     = PWM_CHANNEL_1;
	handlerPWM_1.config.duttyCicle  = 0;
//	counter = 50;
	handlerPWM_1.config.periodo     = 40; // se maneja 25 hz por testeo
	handlerPWM_1.config.prescaler   = PWM_SPEED_100MHz_1us;
	handlerPWM_1.config.polarity    = PWM_ENABLE_POLARITY;
	handlerPWM_1.config.optocoupler = PWM_ENABLE_OPTOCOUPLER;
	pwm_Config(&handlerPWM_1);
	startPwmSignal(&handlerPWM_1);

	//PWM motor 2
	handlerPinPwm_2.pGPIOx                             = GPIOA;
	handlerPinPwm_2.GPIO_PinConfig.GPIO_PinAltFunMode  = AF2;
	handlerPinPwm_2.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handlerPinPwm_2.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerPinPwm_2.GPIO_PinConfig.GPIO_PinNumber      = PIN_1;
	handlerPinPwm_2.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinPwm_2.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerPinPwm_2);

	handlerPWM_2.ptrTIMx            = TIM5;
	handlerPWM_2.config.channel     = PWM_CHANNEL_2;
	handlerPWM_2.config.duttyCicle  = 0;
	handlerPWM_2.config.periodo     = 40;// se maneja 25 hz por testeo
	handlerPWM_2.config.prescaler   = PWM_SPEED_100MHz_1us;
	handlerPWM_2.config.polarity    = PWM_ENABLE_POLARITY;
	handlerPWM_2.config.optocoupler = PWM_ENABLE_OPTOCOUPLER;
	pwm_Config(&handlerPWM_2);
	startPwmSignal(&handlerPWM_2);


	//////////////////////////////////////////////////// /////////////////// //////////////////////////////////////////////

	////////////////////////////////////// Enable 1 y 2, encendido y apagado de motores //////////////////////////////////////////////



	handlerEn1PinC10.pGPIOx                             = GPIOC;
	handlerEn1PinC10.GPIO_PinConfig.GPIO_PinAltFunMode  = AF0;
	handlerEn1PinC10.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_OUT;
	handlerEn1PinC10.GPIO_PinConfig.GPIO_PinNumber      = PIN_10;
	handlerEn1PinC10.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerEn1PinC10.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerEn1PinC10.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerEn1PinC10);
	GPIO_WritePin_Afopt(&handlerEn1PinC10, RESET);

	handlerEn2PinC11.pGPIOx                             = GPIOC;
	handlerEn2PinC11.GPIO_PinConfig.GPIO_PinAltFunMode  = AF0;
	handlerEn2PinC11.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_OUT;
	handlerEn2PinC11.GPIO_PinConfig.GPIO_PinNumber      = PIN_11;
	handlerEn2PinC11.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerEn2PinC11.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerEn2PinC11.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerEn2PinC11);
	GPIO_WritePin_Afopt(&handlerEn2PinC11, RESET);


	//////////////////////////////////////////////////// /////////////////// //////////////////////////////////////////////

	////////////////////////////////////// In 1 y 2, direccion de colores CW y CCW //////////////////////////////////////////////

	handlerIn1PinC12.pGPIOx                             = GPIOC;
	handlerIn1PinC12.GPIO_PinConfig.GPIO_PinAltFunMode  = AF0;
	handlerIn1PinC12.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_OUT;
	handlerIn1PinC12.GPIO_PinConfig.GPIO_PinNumber      = PIN_12;
	handlerIn1PinC12.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerIn1PinC12.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerIn1PinC12.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerIn1PinC12);
	GPIO_WritePin_Afopt(&handlerIn1PinC12, RESET); // default

	handlerIn2PinD2.pGPIOx                             = GPIOD;
	handlerIn2PinD2.GPIO_PinConfig.GPIO_PinAltFunMode  = AF0;
	handlerIn2PinD2.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_OUT;
	handlerIn2PinD2.GPIO_PinConfig.GPIO_PinNumber      = PIN_2;
	handlerIn2PinD2.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerIn2PinD2.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerIn2PinD2.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerIn2PinD2);
	GPIO_WritePin_Afopt(&handlerIn2PinD2, RESET); // default


	//////////////////////////////////////////////////// /////////////////// //////////////////////////////////////////////

	////////////////////////////////////// Conteo de encoders motor 1 y motor 2//////////////////////////////////////////////


	handlerEncoder1PinC1.pGPIOx                             = GPIOC;
	handlerEncoder1PinC1.GPIO_PinConfig.GPIO_PinAltFunMode  = AF0;
	handlerEncoder1PinC1.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_IN;
	handlerEncoder1PinC1.GPIO_PinConfig.GPIO_PinNumber      = PIN_1;
	handlerEncoder1PinC1.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerEncoder1PinC1.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerEncoder1PinC1.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_FAST;
	handlerExtiConEnc_1.pGPIOHandler                        = &handlerEncoder1PinC1;
	handlerExtiConEnc_1.edgeType                            = EXTERNAL_INTERRUPT_RASINGANDFALLING_EDGE;
	extInt_Config(&handlerExtiConEnc_1);

	handlerEncoder2PinC3.pGPIOx                             = GPIOC;
	handlerEncoder2PinC3.GPIO_PinConfig.GPIO_PinAltFunMode  = AF0;
	handlerEncoder2PinC3.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_IN;
	handlerEncoder2PinC3.GPIO_PinConfig.GPIO_PinNumber      = PIN_3;
	handlerEncoder2PinC3.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerEncoder2PinC3.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerEncoder2PinC3.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_FAST;
	handlerExtiConEnc_2.pGPIOHandler                        = &handlerEncoder2PinC3;
	handlerExtiConEnc_2.edgeType                            = EXTERNAL_INTERRUPT_RASINGANDFALLING_EDGE;
	extInt_Config(&handlerExtiConEnc_2);



	//////////////////////////////////////////////////// /////////////////// //////////////////////////////////////////////

	///////////////////////////////////////////Comunicación serial para comandos //////////////////////////////////////////////


	//Comunicacion serial

	handlerPinTx.pGPIOx                             = GPIOA;
	handlerPinTx.GPIO_PinConfig.GPIO_PinAltFunMode  = AF7;
	handlerPinTx.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handlerPinTx.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerPinTx.GPIO_PinConfig.GPIO_PinNumber      = PIN_2;
	handlerPinTx.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinTx.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_HIGH;
	GPIO_Config(&handlerPinTx);

	handlerPinRx.pGPIOx                             = GPIOA;
	handlerPinRx.GPIO_PinConfig.GPIO_PinAltFunMode  = AF7;
	handlerPinRx.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handlerPinRx.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerPinRx.GPIO_PinConfig.GPIO_PinNumber      = PIN_3;
	handlerPinRx.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinRx.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_HIGH;
	GPIO_Config(&handlerPinRx);

	handlerUSART1.ptrUSARTx                      = USART2;
	handlerUSART1.USART_Config.USART_MCUvelocity = USART_50MHz_VELOCITY;
	handlerUSART1.USART_Config.USART_baudrate    = USART_BAUDRATE_19200;
	handlerUSART1.USART_Config.USART_enableInRx  = USART_INTERRUPT_RX_ENABLE;
	handlerUSART1.USART_Config.USART_enableInTx  = USART_INTERRUPT_TX_DISABLE;
	handlerUSART1.USART_Config.USART_mode        = USART_MODE_RXTX;
	handlerUSART1.USART_Config.USART_parity      = USART_PARITY_NONE;
	handlerUSART1.USART_Config.USART_stopbits    = USART_STOPBIT_1;
	handlerUSART1.USART_Config.USART_datasize    = USART_DATASIZE_8BIT;
	USART_Config(&handlerUSART1);

	//////////////////////////////////////////////////// /////////////////// //////////////////////////////////////////////

	///////////////////////////////////////////Timer para el control de la velocidad//////////////////////////////////////////////

	handlerTIM2_vel.ptrTIMx                           = TIM2;
	handlerTIM2_vel.TIMx_Config.TIMx_interruptEnable  = BTIMER_ENABLE_INTERRUPT;
	handlerTIM2_vel.TIMx_Config.TIMx_mode             = BTIMER_MODE_UP;
	handlerTIM2_vel.TIMx_Config.TIMx_speed            = BTIMER_SPEED_100MHz_10us;
	handlerTIM2_vel.TIMx_Config.TIMx_period           = 80;
	Ts = handlerTIM2_vel.TIMx_Config.TIMx_period;
	BasicTimer_Config(&handlerTIM2_vel);


	//////////////////////////////////////////////////// /////////////////// //////////////////////////////////////////////

	///////////////////////////////////////////Motores 1 y 2//////////////////////////////////////////////


	handlerMotor1.configM1.e_M1   = 0;
	handlerMotor1.configM1.e_M1_1 = 0;
	handlerMotor1.configM1.e_M1_2 = 0;


	handlerMotor2.configM2.e_M2   = 0;
	handlerMotor2.configM2.e_M2_1 = 0;
	handlerMotor2.configM2.e_M2_2 = 0;

	//////////////////////////////////////////////////// /////////////////// //////////////////////////////////////////////

		////////////////////////////////Configuracion PINES B8 (SCL) B9 (SDA) e I2C1 //////////////////////////////////////////////

	handler_PINB8_I2C1.pGPIOx                             = GPIOB;
	handler_PINB8_I2C1.GPIO_PinConfig.GPIO_PinAltFunMode  = AF4;
	handler_PINB8_I2C1.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handler_PINB8_I2C1.GPIO_PinConfig.GPIO_PinNumber      = PIN_8;
	handler_PINB8_I2C1.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_OPENDRAIN;
	handler_PINB8_I2C1.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handler_PINB8_I2C1.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_HIGH;

	handler_PINB9_I2C1.pGPIOx                             = GPIOB;
	handler_PINB9_I2C1.GPIO_PinConfig.GPIO_PinAltFunMode  = AF4;
	handler_PINB9_I2C1.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handler_PINB9_I2C1.GPIO_PinConfig.GPIO_PinNumber      = PIN_9;
	handler_PINB9_I2C1.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_OPENDRAIN;
	handler_PINB9_I2C1.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handler_PINB9_I2C1.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_HIGH;

	handler_I2C1.ptrI2Cx = I2C1;
	handler_I2C1.I2C_Config.clkSpeed = MAIN_CLOCK_50_MHz_FOR_I2C;
	handler_I2C1.I2C_Config.slaveAddress = ADDRESS_DOWN;
	handler_I2C1.I2C_Config.modeI2C = I2C_MODE_FM;

	handler_MPUAccel_6050.ptrGPIOhandlerSCL  = &handler_PINB8_I2C1;
	handler_MPUAccel_6050.ptrGPIOhandlerSDA  = &handler_PINB9_I2C1;
	handler_MPUAccel_6050.ptrI2Chandler   = &handler_I2C1;
	handler_MPUAccel_6050.fullScaleACCEL  = ACCEL_2G;
	handler_MPUAccel_6050.fullScaleGYRO   = GYRO_250;
	configMPUAccel(&handler_MPUAccel_6050);


	//////////////////////////////////////////////////// /////////////////// //////////////////////////////////////////////

	////////////////////////////////Timer 5 para contador de tiempo ////////////////////////////////////



	handlerTIM4_time.ptrTIMx                           = TIM4;
	handlerTIM4_time.TIMx_Config.TIMx_interruptEnable  = BTIMER_ENABLE_INTERRUPT;
	handlerTIM4_time.TIMx_Config.TIMx_mode             = BTIMER_MODE_UP;
	handlerTIM4_time.TIMx_Config.TIMx_speed            = BTIMER_SPEED_100MHz_100us;
	handlerTIM4_time.TIMx_Config.TIMx_period           = 1000;
	BasicTimer_Config(&handlerTIM4_time);

}


void parseCommands(char *stringVector){

	sscanf(stringVector, "%s %u %u %u %s", cmd ,&firstParameter, &secondParameter, &thirdParameter, userMsg);




	if (strcmp(cmd, "help") == 0){

		writeMsg(&handlerUSART1, "HELP MENU CMD : \n");
		writeMsg(&handlerUSART1, "1)  start #setPoint #dir --- setPoint de 0 a 9 ---  dir 0 CW 1 CCW \n");
		writeMsg(&handlerUSART1, "2)  goTo #dutty #dir #distance  -----dutty de 0 a 100 ||  dir 0 CW 1 CCW || Distancia en mm \n" );
		writeMsg(&handlerUSART1, "3)  off \n");
		writeMsg(&handlerUSART1, "4)  gyro \n");
		writeMsg(&handlerUSART1, " \n");

	}else if (strcmp(cmd, "start") == 0){

		dist_1 = 0;
		dist_2 = 0;

		handlerMotor1.configM1.counts_M1 = 0;
		handlerMotor2.configM2.counts_M2 = 0;

		// Se setea El setpoint
		setPoint = firstParameter;

		if (!flagPWM_1){

			//Se setea la direccion
			GPIO_WritePin_Afopt(&handlerIn1PinC12, secondParameter);

			//Se enciende el motor 1
			flagPWM_1 = enableOutput(&handlerPWM_1);
			GPIO_WritePin_Afopt (&handlerEn1PinC10,SET);


		}else{

			__NOP();
		}


		if (!flagPWM_2){


			// Se setea la direccion seleccionada
			GPIO_WritePin_Afopt(&handlerIn2PinD2, secondParameter);

			//Se enciende el motor 2
			flagPWM_2 = enableOutput(&handlerPWM_2);
			GPIO_WritePin_Afopt (&handlerEn2PinC11,SET);


		}else{
			__NOP();
		}


		startTimer(&handlerTIM2_vel);
		enableChangePWM = SET;


	}else if (strcmp(cmd, "goTo") == 0){

		dist_1 = 0;
		dist_2 = 0;

		handlerMotor1.configM1.counts_M1 = 0;
		handlerMotor2.configM2.counts_M2 = 0;

		distance = thirdParameter;
		setPoint = thirdParameter;


		if (!flagPWM_1){

			// Seteamos los parametros para PID
			handlerMotor1.configM1.u_M1_1 = setPoint / k;
			setConstants(&handlerMotor1, 1, k, tau, theta, Ts);

			// Se setea su PWM

			updateDuttyCycleAfOpt(&handlerPWM_1, firstParameter);
			counterPWM1 = showPWMBfOpt(&handlerPWM_1);

			// Se setea la direccion seleccionada
			GPIO_WritePin_Afopt(&handlerIn1PinC12, secondParameter);

			//Se enciende el motor 2
			flagPWM_1 = enableOutput(&handlerPWM_1);
			GPIO_WritePin_Afopt (&handlerEn1PinC10,SET);


		}else{
			__NOP();
		}

		if (!flagPWM_2){

			// Seteo de los parametros PID
			handlerMotor2.configM2.u_M2_1 = setPoint / k;
			setConstants(&handlerMotor2, 2, k, tau, theta, Ts);

			// Se setea su PWM

			updateDuttyCycleAfOpt(&handlerPWM_2, firstParameter);
			counterPWM2 = showPWMBfOpt(&handlerPWM_2);

			// Se setea la direccion seleccionada
			GPIO_WritePin_Afopt(&handlerIn2PinD2, secondParameter);

			//Se enciende el motor 2
			flagPWM_2 = enableOutput(&handlerPWM_2);
			GPIO_WritePin_Afopt (&handlerEn2PinC11,SET);


		}else{
			__NOP();
		}

		startTimer(&handlerTIM2_vel);
		enableChangePWM = SET;


	}else if (strcmp(cmd, "off") == 0){

		//Se pregunta cual motor se quiere apagar

		if (flagPWM_1){

			//Se apagael motor 1
			flagPWM_1 = disableOutput(&handlerPWM_1);
			GPIO_WritePin_Afopt (&handlerEn1PinC10,RESET);


		}else{

			__NOP();

		}



		if (flagPWM_2){

			//Se apaga el motor 2
			flagPWM_2 = disableOutput(&handlerPWM_2);
			GPIO_WritePin_Afopt (&handlerEn2PinC11,RESET);


		}else{
			__NOP();
		}



		stopTimer(&handlerTIM2_vel);
		enableChangePWM = RESET;



	}else if (strcmp(cmd, "gyro") == 0){

		calibr = calibracionGyros(&handler_MPUAccel_6050, 'z');
		startTimer(&handlerTIM4_time);

	}


	else {
		writeMsg(&handlerUSART1, "Comando Incorrecto :c \n");


	}


}



double distanceM1 (void){

	double u_1;

	u_1 = M_PI * (51.45) * handlerMotor1.configM1.counts_M1/ (72) ;

	return u_1;
}

double distanceM2 (void){

	double u_2;

	u_2 = M_PI * (51.70) * handlerMotor2.configM2.counts_M2/ (72) ;

	return u_2;
}


// Interrupcion usart 1
void usart2Rx_Callback(void){

	rxData = getRxData();

}

//Interrupcion Timer 4
void BasicTimer4_Callback(void){

	flagGyro = SET;
	tiempo += 1;

}

//Interrupción Timer 3
void BasicTimer3_Callback(void){

	GPIOxTooglePin(&handlerPinA5);
	counterTIM3++;

}

//Interrupcion Timer 2

void BasicTimer2_Callback(void){

	flagT2 = SET;


}


//Interrupciones de Exti
void callback_extInt1(void){

	handlerMotor1.configM1.counts_M1++;

}

void callback_extInt3(void){

	handlerMotor2.configM2.counts_M2++;
}


//Definicion de funciones varias

// Freno de motores
void breakMotor(void){

	//Se pregunta cual motor se quiere apagar

	if (flagPWM_1){

		//Se apagael motor 1
		flagPWM_1 = disableOutput(&handlerPWM_1);
		GPIO_WritePin_Afopt (&handlerEn1PinC10,RESET);


	}else{

		__NOP();

	}



	if (flagPWM_2){

		//Se apaga el motor 2
		flagPWM_2 = disableOutput(&handlerPWM_2);
		GPIO_WritePin_Afopt (&handlerEn2PinC11,RESET);


	}else{
		__NOP();
	}



	stopTimer(&handlerTIM2_vel);
	enableChangePWM = RESET;


}


// Calibracion Gyros:

float calibracionGyros (MPUAccel_Config *ptrMPUAccel, uint8_t axis){

	uint16_t  numMedidas = 250;
	float    medidas    = 0;
	float    suma       = 0;
	uint8_t  contador   = 0;
	float    promedio   = 0;
	uint32_t i = 0;

	switch (axis) {
		case 'x':{
			while (contador < numMedidas){
				medidas = readGyro_X(ptrMPUAccel);
				for (i = 0; i< pow(10,6);i++){}
				suma += medidas;
				contador++;
			}
			promedio = suma / numMedidas;
			break;
		}case 'y':{
			while (contador < numMedidas){
				medidas = readGyro_Y(ptrMPUAccel);
				for (i = 0; i< pow(10,6);i++){}
				suma += medidas;
				contador++;
			}
			promedio = suma / numMedidas;
			break;
		}case 'z':{
			while (contador < numMedidas){
				medidas = readGyro_Z(ptrMPUAccel);
				for (i = 0; i< pow(10,6);i++){}
				suma += medidas;
				contador++;
			}
			promedio = suma / numMedidas;
			break;
		}default:{
			break;
		}
	}


	return promedio;
}










//void vTaskOne( void * pvParameters )
//{
//
//	BaseType_t notify_state ={0};
//	uint8_t flag = RESET;
//
//   while(1){
//	   //printf("%s\n",((char*) pvParameters));
//	   if (notify_state == pdTRUE){
//		   flag = !flag;
//   	   //vTaskDelay((pdMS_TO_TICKS(100)));
//	   }
//
//	   if (flag){
//		   GPIOxTooglePin(&handlerPinA5);
//	   }
//	   else{
//
//		   GPIO_WritePin(&handlerPinA5, RESET);
//	   }
//
//	   notify_state = xTaskNotifyWait(0,0,NULL,pdMS_TO_TICKS(100));
//	   //taskYIELD();
//   }
//}
//
//void vTaskTwo( void * pvParameters )
//{
//
//	uint8_t button_state = 0;
//	uint8_t prev_button_state = 0;
//
//   while(1){
////	   printf("%s\n",((char*) pvParameters));
//	   button_state = GPIO_ReadPin(&handlerUserButton);
//
//	   if (button_state){
//		   if (!prev_button_state){
//			   //Notificacion
//			   xTaskNotify(xHandleTask1,0,eNoAction);
//
//		   }
//	   }
//
//	   prev_button_state = button_state;
//
//	   vTaskDelay((pdMS_TO_TICKS(10)));
//	   //GPIO_WritePin(&handlerPinA5, SET);
//	   //taskYIELD();
//   }
//}
