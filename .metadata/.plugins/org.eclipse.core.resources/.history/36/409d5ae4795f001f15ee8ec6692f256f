 /**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stm32f4xx.h>

#include <stdint.h>
#include <stdbool.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>  // for usleep


#include "GPIOxDriver.h"
#include "BasicTimer.h"
#include "PwmDriver.h"
#include "USARTxDriver.h"
#include "RCCHunMHz.h"

/*definicion de variables del sistema*/


void inSystem (void);
void parseCommands(char *stringVector);



//Definici√≥n Handlers
//GPIO
//Pin del User blinky
GPIO_Handler_t handlerPinA5         = {0};


//Pin PWM que controla el pulso a 10 ns
GPIO_Handler_t handlerPinPwm_pulse_10ns  = {0};

//Pin para visualizar la velocidad del micro
GPIO_Handler_t handlerMCO2Show      = {0};

//Timers
BasicTimer_Handler_t handlerTimerBlinky = {0}; // Timer 3
BasicTimer_Handler_t handlerTIM2_vel    = {0}; // Timer 2

//PWMs
PWM_Handler_t handlerPWM_pulse_10ns = {0}; // Timer 5

// Variables para los comandos
char bufferReception[64];
uint8_t counterReception = 0;
uint8_t doneTransaction = RESET;
uint8_t rxData = '\0';
char cmd[32];
unsigned int firstParameter;
unsigned int secondParameter;
unsigned int thirdParameter;
char userMsg[64];
char bufferMsg[64];

int main(void)
{



	inSystem ();

    /* Loop forever */
	while(1){


	}
}


void inSystem (void){


	// Activamos la maxima velocidad del microcontrolador
	RCC_enableMaxFrequencies();
	//Config del pin A8 salida de la velocidad del micro

//	handlerMCO2Show.pGPIOx                             = GPIOC;
//	handlerMCO2Show.GPIO_PinConfig.GPIO_PinNumber      = PIN_9 ;
//	handlerMCO2Show.GPIO_PinConfig.GPIO_PinAltFunMode  = AF0;
//	handlerMCO2Show.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
//	GPIO_Config(&handlerMCO2Show);

	//BLINKY LED

	handlerPinA5.pGPIOx = GPIOA;
	handlerPinA5.GPIO_PinConfig.GPIO_PinAltFunMode = AF0;
	handlerPinA5.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	handlerPinA5.GPIO_PinConfig.GPIO_PinOPType = GPIO_OTYPE_PUSHPULL;
	handlerPinA5.GPIO_PinConfig.GPIO_PinNumber = PIN_5;
	handlerPinA5.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinA5.GPIO_PinConfig.GPIO_PinSpeed = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerPinA5);
	GPIO_WritePin(&handlerPinA5, SET);

	handlerTimerBlinky.ptrTIMx                           = TIM3;
	handlerTimerBlinky.TIMx_Config.TIMx_interruptEnable  = BTIMER_ENABLE_INTERRUPT;
	handlerTimerBlinky.TIMx_Config.TIMx_mode             = BTIMER_MODE_UP;
	handlerTimerBlinky.TIMx_Config.TIMx_speed            = BTIMER_SPEED_100MHz_100us;
	handlerTimerBlinky.TIMx_Config.TIMx_period           = 1000;
	BasicTimer_Config(&handlerTimerBlinky);
	startTimer(&handlerTimerBlinky);

	// PWM handler del GPIO y el PWM

	handlerPinPwm_pulse_10ns.pGPIOx                             = GPIOA;
	handlerPinPwm_pulse_10ns.GPIO_PinConfig.GPIO_PinAltFunMode  = AF2;
	handlerPinPwm_pulse_10ns.GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTFN;
	handlerPinPwm_pulse_10ns.GPIO_PinConfig.GPIO_PinOPType      = GPIO_OTYPE_PUSHPULL;
	handlerPinPwm_pulse_10ns.GPIO_PinConfig.GPIO_PinNumber      = PIN_0;
	handlerPinPwm_pulse_10ns.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinPwm_pulse_10ns.GPIO_PinConfig.GPIO_PinSpeed       = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerPinPwm_pulse_10ns);

	handlerPWM_pulse_10ns.ptrTIMx            = TIM5;
	handlerPWM_pulse_10ns.config.channel     = PWM_CHANNEL_1;
	handlerPWM_pulse_10ns.config.duttyCicle  = 50;
	handlerPWM_pulse_10ns.config.periodo     = 40; // se maneja 25 hz por testeo
	handlerPWM_pulse_10ns.config.prescaler   = PWM_SPEED_100MHz_1us;
	handlerPWM_pulse_10ns.config.polarity    = PWM_DISABLE_POLARITY;
	handlerPWM_pulse_10ns.config.optocoupler = PWM_DISABLE_OPTOCOUPLER;
	pwm_Config(&handlerPWM_pulse_10ns);
	startPwmSignal(&handlerPWM_pulse_10ns);

}


void parseCommands(char *stringVector){

	sscanf(stringVector, "%s %u %u %u %s", cmd ,&firstParameter, &secondParameter, &thirdParameter, userMsg);




	if (strcmp(cmd, "help") == 0){


	}

}


