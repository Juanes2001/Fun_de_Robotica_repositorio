/*
 * main2.c
 *
 *  Created on: Aug 2, 2024
 *      Author: juan
 */


#include <stm32f4xx.h>


#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "timers.h"

#include <stdint.h>
#include <stdbool.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "GPIOxDriver.h"
#include "BasicTimer.h"
#include "PwmDriver.h"
#include "EXTIDriver.h"
#include "RCCHunMHz.h"

/*definicion de variables del sistema*/


#define STACK_SIZE 200

uint32_t SystemCoreClock = 100000000;

BaseType_t xReturned;
/*Cabecera de la funcion de tarea 1 */
void vTask_Menu( void * pvParameters );
void vTask_Print( void * pvParameters );
void vTask_Commands( void * pvParameters );


TaskHandle_t xHandleTask_Menu     = NULL;
TaskHandle_t xHandleTask_Print    = NULL;
TaskHandle_t xHandleTask_Commands = NULL;

QueueHandle_t xQueue_Print;
QueueHandle_t xQueue_InputData;

void inSystem (void);
void parseCommands(char *stringVector);

//Definición Handlers
//GPIO
GPIO_Handler_t handlerPinA5           = {};
GPIO_Handler_t handlerUserButton      = {};
EXTI_Config_t  handler_exti_userButon = {};

//Timers
BasicTimer_Handler_t handlerTimerBlinky = {};

// Variables para los comandos
char bufferReception[64];
uint32_t len; // tamaño de datos recibidos
uint8_t counterReception = 0;
uint8_t doneTransaction = RESET;
uint8_t rxData = '\0';
char cmd[32];

typedef struct{
	uint8_t payload[10];
	uint32_t len;

}command_t;

typedef enum {
	sMainMenu = 0,
	sLedEffect,
	sRtcMenu
}state_t;

unsigned int firstParameter;
unsigned int secondParameter;
unsigned int thirdParameter;
char userMsg[64];

int main(void)
{


	//Activamos el FPU o la unidad de punto flotante
	SCB -> CPACR |= (0xF << 20);


	//Activamos el contador
   	DWT -> CTRL    |= (1 << 0);

	// Configuracion de orden de prioridad
	//vInitPrioGroupValue();
//
//	/* Primero configuramos */
//	SEGGER_SYSVIEW_Conf();
//	/* Despues activamos el sistema */
//	SEGGER_SYSVIEW_Start();


	inSystem ();

	xReturned = xTaskCreate(
						vTaskLedGreen,       /* Function that implements the task. */
	                    "Task-LED",          /* Text name for the task. */
	                    STACK_SIZE,      /* Stack size in words, not bytes. */
						"Blinky Led",    /* Parameter passed into the task. */
	                    3,/* Priority at which the task is created. */
	                    &xHandleTask_Led );      /* Used to pass out the created task's handle. */


	 configASSERT( xReturned == pdPASS );

//	 xReturned = xTaskCreate(
//	 	                    vTaskTwo,       /* Function that implements the task. */
//	 	                    "Task-Button",          /* Text name for the task. */
//	 	                    STACK_SIZE,      /* Stack size in words, not bytes. */
//	 	                    "HOLA MUNDO",    /* Parameter passed into the task. */
//	 	                    3,/* Priority at which the task is created. */
//	 	                    &xHandleTask_Button );      /* Used to pass out the created task's handle. */


	 /* Start the created tasks running. */
	 vTaskStartScheduler();


    /* Loop forever */
	while(1){
//		GPIOxTooglePin(&handlerPinA5);
//		for (uint16_t steps = 0 ; steps < 10000 ;steps++){
//
//		}


//		if (rxData != '\0'){
//			bufferReception[counterReception] = rxData;
//			counterReception++;
//
//			if (rxData == '@'){
//				doneTransaction = SET;
//
//				bufferReception[counterReception] = '\0';
//
//				counterReception = 0;
//
//			}
//
//			rxData = '\0';
//
//		}
//
//		if (doneTransaction){
//			parseCommands(bufferReception);
//			doneTransaction = RESET;
//		}
//
		//Si se llega hasta aca es porque algo salio mal

	}
}


void inSystem (void){




	//Descripcion de la configuracion

	// Activamos la maxima velocidad del microcontrolador
	RCC_enableMaxFrequencies();

	//BLINKY LED
	handlerPinA5.pGPIOx = GPIOA;
	handlerPinA5.GPIO_PinConfig.GPIO_PinAltFunMode = AF0;
	handlerPinA5.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	handlerPinA5.GPIO_PinConfig.GPIO_PinOPType = GPIO_OTYPE_PUSHPULL;
	handlerPinA5.GPIO_PinConfig.GPIO_PinNumber = PIN_5;
	handlerPinA5.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerPinA5.GPIO_PinConfig.GPIO_PinSpeed = GPIO_OSPEEDR_FAST;
	GPIO_Config(&handlerPinA5);
	GPIO_WritePin(&handlerPinA5, RESET);


	// USER Button exti config
	handlerUserButton.pGPIOx = GPIOC;
	handlerUserButton.GPIO_PinConfig.GPIO_PinAltFunMode = AF0;
	handlerUserButton.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN;
	handlerUserButton.GPIO_PinConfig.GPIO_PinOPType = GPIO_OTYPE_PUSHPULL;
	handlerUserButton.GPIO_PinConfig.GPIO_PinNumber = PIN_13;
	handlerUserButton.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerUserButton.GPIO_PinConfig.GPIO_PinSpeed = GPIO_OSPEEDR_FAST;
	handler_exti_userButon.edgeType = EXTERNAL_INTERRUPT_RISING_EDGE;
	handler_exti_userButon.pGPIOHandler = &handlerUserButton;
	handler_exti_userButon.priority     = e_EXTI_PRIORITY_6;
	exti_Set_Priority(&handler_exti_userButon, e_EXTI_PRIORITY_6);
	extInt_Config(&handler_exti_userButon);




}



void vTaskLedGreen( void * pvParameters )
{

	BaseType_t notifyStatus = {0};
	uint8_t controlLed      = 0;

   while(1){
	   //printf("%s\n",((char*) pvParameters));
	   if (controlLed){
		   GPIOxTooglePin(&handlerPinA5);

	   }else{
		   GPIO_WritePin(&handlerPinA5, RESET);
	   }


	   notifyStatus = xTaskNotifyWait(0,0,NULL,pdMS_TO_TICKS(250));

	   if (notifyStatus == pdTRUE){

		   //Para desactiva	r las interrupciones por un pequeño instante
		   portENTER_CRITICAL();

		   controlLed = !controlLed;

		   //Las volvemos a activar
		   portEXIT_CRITICAL();
	   }
	   //taskYIELD();
   }
}

//void vTaskTwo( void * pvParameters )
//{
//
//   while(1){
////	   printf("%s\n",((char*) pvParameters));
//	   vTaskDelay((pdMS_TO_TICKS(10)));
//	   //GPIO_WritePin(&handlerPinA5, SET);
//	   //taskYIELD();
//   }
//}

void usart2Rx_Callback(void){




}


void callback_extInt13(void){

	BaseType_t pxHiguerPriorityTaskWoken;
	pxHiguerPriorityTaskWoken = pdFALSE;

	//Notoficamos a la funcion del LED:
	xTaskNotifyFromISR(xHandleTask_Led,0,eNoAction,&pxHiguerPriorityTaskWoken);


}



void parseCommands(char *stringVector){

	sscanf(stringVector, "%s %u %u %u %s", cmd ,&firstParameter, &secondParameter, &thirdParameter, userMsg);

}
